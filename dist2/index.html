<!DOCTYPE html>
<html lang="ru">

<head>
	<title>Главная</title>
	<meta charset="UTF-8">
	<meta name="format-detection" content="telephone=no">
	<link rel="shortcut icon" href="favicon.ico">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<style>
		@charset "UTF-8";

		@font-face {
			font-family: Brygada1918;
			font-display: swap;
			src: url("../fonts/Brygada1918-SemiBold.woff2") format("woff2"), url("../fonts/Brygada1918-SemiBold.woff") format("woff");
			font-weight: 600;
			font-style: normal;
		}

		@font-face {
			font-family: Brygada1918;
			font-display: swap;
			src: url("../fonts/Brygada1918-Regular.woff2") format("woff2"), url("../fonts/Brygada1918-Regular.woff") format("woff");
			font-weight: 400;
			font-style: normal;
		}

		@font-face {
			font-family: Inter;
			font-display: swap;
			src: url("../fonts/Inter-Regular.woff2") format("woff2"), url("../fonts/Inter-Regular.woff") format("woff");
			font-weight: 400;
			font-style: normal;
		}

		@font-face {
			font-family: Manrope;
			font-display: swap;
			src: url("../fonts/Manrope-SemiBold.woff2") format("woff2"), url("../fonts/Manrope-SemiBold.woff") format("woff");
			font-weight: 600;
			font-style: normal;
		}

		@font-face {
			font-family: Manrope;
			font-display: swap;
			src: url("../fonts/Manrope-Bold.woff2") format("woff2"), url("../fonts/Manrope-Bold.woff") format("woff");
			font-weight: 700;
			font-style: normal;
		}

		@font-face {
			font-family: Manrope;
			font-display: swap;
			src: url("../fonts/Manrope-Regular.woff2") format("woff2"), url("../fonts/Manrope-Regular.woff") format("woff");
			font-weight: 400;
			font-style: normal;
		}

		@font-face {
			font-family: Inter;
			font-display: swap;
			src: url("../fonts/Inter-SemiBold.woff2") format("woff2"), url("../fonts/Inter-SemiBold.woff") format("woff");
			font-weight: 600;
			font-style: normal;
		}

		@font-face {
			font-family: OfficinaSerifBookCTT;
			font-display: swap;
			src: url("../fonts/OfficinaSerifBookC.woff2") format("woff2"), url("../fonts/OfficinaSerifBookC.woff") format("woff");
			font-weight: 400;
			font-style: normal;
		}

		@font-face {
			font-family: Tenor Sans;
			font-display: swap;
			src: url("../fonts/tenorsans.woff2") format("woff2"), url("../fonts/tenorsans.woff") format("woff");
			font-weight: 400;
			font-style: normal;
		}

		:root {
			--font-family: "Brygada1918", sans-serif;
			--second-family: "Manrope", sans-serif;
			--third-family: "Tenor Sans", sans-serif;
			--font3: "Inter", sans-serif;
			--font4: "OfficinaSerifBookCTT", sans-serif;
		}

		* {
			padding: 0px;
			margin: 0px;
			border: 0px;
		}

		*,
		*:before,
		*:after {
			-webkit-box-sizing: border-box;
			box-sizing: border-box;
		}

		html,
		body {
			height: 100%;
			min-width: 320px;
		}

		body {
			color: #000;
			line-height: 1.2;
			font-family: var(--font-family);
			font-size: 14px;
			-ms-text-size-adjust: 100%;
			-moz-text-size-adjust: 100%;
			-webkit-text-size-adjust: 100%;
			-webkit-font-smoothing: antialiased;
			-moz-osx-font-smoothing: grayscale;
		}

		input,
		button,
		textarea {
			font-family: var(--font-family);
			font-size: inherit;
			outline: none;
		}

		button {
			cursor: pointer;
			color: inherit;
			background-color: inherit;
		}

		a {
			color: inherit;
		}

		a:link,
		a:visited {
			text-decoration: none;
		}

		a:hover {
			text-decoration: none;
		}

		ul li {
			list-style: none;
		}

		img {
			vertical-align: top;
		}

		h1,
		h2,
		h3,
		h4,
		h5,
		h6 {
			font-weight: inherit;
			font-size: inherit;
		}

		.lock body {
			overflow: hidden;
			-ms-touch-action: none;
			touch-action: none;
			-ms-scroll-chaining: none;
			overscroll-behavior: none;
		}

		.wrapper {
			min-height: 100%;
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-orient: vertical;
			-webkit-box-direction: normal;
			-ms-flex-direction: column;
			flex-direction: column;
			overflow: hidden;
		}

		.wrapper>main {
			-webkit-box-flex: 1;
			-ms-flex: 1 1 auto;
			flex: 1 1 auto;
		}

		.wrapper>* {
			min-width: 0;
		}

		/*
(i) Стили будут применяться ко 
всем классам содержащим *__container
Например header__container, main__container и т.д.
Снипет (HTML): cnt
*/

		[class*=__container] {
			max-width: 72.5rem;
			-webkit-box-sizing: content-box;
			box-sizing: content-box;
			margin: 0 auto;
			padding: 0 1.25rem;
		}

		.button {
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-pack: center;
			-ms-flex-pack: center;
			justify-content: center;
			-webkit-box-align: center;
			-ms-flex-align: center;
			align-items: center;
			text-align: center;
			-webkit-transition: all 0.3s ease 0s;
			-o-transition: all 0.3s ease 0s;
			transition: all 0.3s ease 0s;
			font-weight: 600;
			font-size: 23px;
			line-height: 177%;
			color: #fff;
			-webkit-box-shadow: inset 5px 9px 21px 5px rgba(255, 255, 255, 0.25), 0 4px 0 0 #125c92;
			box-shadow: inset 5px 9px 21px 5px rgba(255, 255, 255, 0.25), 0 4px 0 0 #125c92;
			background-color: #2894e3;
			border-radius: 12px;
			padding: 23px 50px;
			-webkit-transition: background-color 0.3s ease 0s;
			-o-transition: background-color 0.3s ease 0s;
			transition: background-color 0.3s ease 0s;
		}

		.button:hover {
			background-color: #217cbd;
		}

		body::after {
			content: "";
			-webkit-backdrop-filter: blur(16px);
			backdrop-filter: blur(16px);
			background-color: rgba(0, 0, 0, 0.4);
			position: fixed;
			width: 100%;
			height: 100%;
			top: 0;
			left: 0;
			opacity: 0;
			-webkit-transition: opacity 0.8s ease 0s;
			-o-transition: opacity 0.8s ease 0s;
			transition: opacity 0.8s ease 0s;
			pointer-events: none;
			z-index: 149;
		}

		.popup-show body::after {
			opacity: 1;
		}

		.popup {
			position: fixed;
			top: 0;
			left: 0;
			bottom: 0;
			right: 0;
			padding: 50px 10px;
			-webkit-transition: visibility 0.8s ease 0s;
			-o-transition: visibility 0.8s ease 0s;
			transition: visibility 0.8s ease 0s;
			visibility: hidden;
			pointer-events: none;
		}

		.popup_show {
			z-index: 150;
			visibility: visible;
			overflow: auto;
			pointer-events: auto;
		}

		.popup_show .popup__content {
			visibility: visible;
			-webkit-transform: scale(1);
			-ms-transform: scale(1);
			transform: scale(1);
		}

		.popup__wrapper {
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-orient: vertical;
			-webkit-box-direction: normal;
			-ms-flex-direction: column;
			flex-direction: column;
			-webkit-box-align: center;
			-ms-flex-align: center;
			align-items: center;
			min-height: 100%;
			-webkit-box-flex: 1;
			-ms-flex: 1 1 auto;
			flex: 1 1 auto;
			width: 100%;
			display: flex;
			-webkit-box-pack: center;
			-ms-flex-pack: center;
			justify-content: center;
			align-items: center;
		}

		.popup__content {
			visibility: hidden;
			-webkit-transform: scale(0);
			-ms-transform: scale(0);
			transform: scale(0);
			-webkit-transition: -webkit-transform 0.3s ease 0s;
			transition: -webkit-transform 0.3s ease 0s;
			-o-transition: transform 0.3s ease 0s;
			transition: transform 0.3s ease 0s;
			transition: transform 0.3s ease 0s, -webkit-transform 0.3s ease 0s;
			width: 100%;
			background: transparent;
			padding: 0px 0px 0px 0px;
			max-width: 400px;
			-webkit-box-shadow: none;
			box-shadow: none;
			border-radius: 20px;
		}

		.lock .popup__content {
			visibility: visible;
		}

		.popup__close {
			cursor: pointer;
			position: absolute;
			top: -40px;
			right: 0;
			border-radius: 5px;
			-webkit-box-flex: 0;
			-ms-flex: 0 0 28px;
			flex: 0 0 28px;
			width: 28px;
			height: 28px;
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-pack: center;
			-ms-flex-pack: center;
			justify-content: center;
			-webkit-box-align: center;
			-ms-flex-align: center;
			align-items: center;
		}

		.popup__video {
			cursor: pointer;
			position: relative;
			width: 100%;
			height: calc(100vh - 50px);
			border-radius: 8px;
			overflow: hidden;
		}

		.popup__item-video {
			position: absolute;
			top: 0;
			right: 0;
			-o-object-fit: cover;
			object-fit: cover;
			cursor: pointer;
			width: 100%;
			height: 100%;
			border-radius: 8px;
		}

		.ibg {
			width: 100%;
			height: 100%;
			-o-object-fit: cover;
			object-fit: cover;
		}

		.ibg--top {
			-o-object-position: top;
			object-position: top;
		}

		.ibg--bottom {
			-o-object-position: bottom;
			object-position: bottom;
		}

		.ibg--left {
			-o-object-position: left;
			object-position: left;
		}

		.ibg--right {
			-o-object-position: right;
			object-position: right;
		}

		.ibg--contain {
			-o-object-fit: contain;
			object-fit: contain;
		}

		.title1 {
			font-family: var(--third-family);
			font-weight: 400;
			font-size: 42px;
			line-height: 117%;
			color: #ab835f;
		}

		.title2 {
			font-weight: 400;
			font-size: 47px;
			line-height: 90%;
			color: #fff;
		}

		.nav {
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-align: center;
			-ms-flex-align: center;
			align-items: center;
			gap: 0px 35px;
			margin: -10px 0px 0px 0px;
		}

		.nav__paginations {
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-align: center;
			-ms-flex-align: center;
			align-items: center;
			gap: 10px 26px;
		}

		.nav__arrows {
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			gap: 0px 10px;
		}

		.pagination-bullets {
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			gap: 0px 10px;
			width: 100px;
		}

		.pagination-bullets .swiper-pagination-bullet {
			cursor: pointer;
			-webkit-box-flex: 0;
			-ms-flex: 0 0 10px;
			flex: 0 0 10px;
			height: 10px;
			border-radius: 5px;
			background: rgba(255, 255, 255, 0.2);
			border-radius: 50%;
		}

		.pagination-bullets .swiper-pagination-bullet-active {
			background: #ab835f;
		}

		.pagination-fraction {
			white-space: nowrap;
			font-family: var(--font3);
			font-weight: 400;
			font-size: 22px;
			line-height: 110%;
			color: rgba(255, 255, 255, 0.7);
		}

		.arrow-prev {
			cursor: pointer;
			width: 45px;
			height: 45px;
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-pack: center;
			-ms-flex-pack: center;
			justify-content: center;
			-webkit-box-align: center;
			-ms-flex-align: center;
			align-items: center;
			border-radius: 8px;
			background: #ab835f;
		}

		.arrow-next {
			cursor: pointer;
			width: 45px;
			height: 45px;
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-pack: center;
			-ms-flex-pack: center;
			justify-content: center;
			-webkit-box-align: center;
			-ms-flex-align: center;
			align-items: center;
			border-radius: 8px;
			background: #ab835f;
		}

		.header {
			display: block;
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			background-color: #2894e3;
			z-index: 50;
			transition: opacity 0.3s ease 0s;
		}

		.header:hover {
			opacity: 0.9;
		}

		.header__content {
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-align: center;
			-ms-flex-align: center;
			align-items: center;
			padding: 20px 0px 20px 10px;
		}

		.header__content img {
			width: 28px;
			height: 28px;
			margin: 0px 16px 0px 0px;
		}

		.header__content span {
			font-size: 28px;
			color: #fff;
			font-family: var(--font3);
		}

		.footer {
			background: #373737;
		}

		.footer__copy {
			border-top: 1px solid rgba(255, 255, 255, 0.27);
			padding: 46px 0px 62px 0px;
			font-family: var(--second-family);
			font-weight: 600;
			font-size: 20px;
			line-height: 164%;
			text-align: center;
			color: rgba(255, 255, 255, 0.27);
		}

		.main-home {
			position: relative;
			background: #313437;
			min-height: 745px;
		}

		.main-home::after {
			content: "";
			position: absolute;
			bottom: 0;
			left: 0;
			width: 100%;
			height: 66%;
			background: -webkit-gradient(linear, left bottom, left top, from(#000), to(rgba(0, 0, 0, 0)));
			background: -o-linear-gradient(bottom, #000 0%, rgba(0, 0, 0, 0) 100%);
			background: linear-gradient(360deg, #000 0%, rgba(0, 0, 0, 0) 100%);
		}

		.main-home__bg {
			position: absolute;
			top: 0;
			right: -435px;
			width: auto;
			height: 100%;
			mix-blend-mode: color-burn;
		}

		.main-home__container {
			position: relative;
		}

		.main-home__content {
			position: relative;
			z-index: 10;
			padding: 74px 0px 114px 0px;
			min-height: 745px;
			max-width: 640px;
		}

		.main-home__content h1 {
			margin: 0px 0px 25px 0px;
		}

		.main-home__image {
			position: absolute;
			bottom: 0;
			right: -233px;
			height: 100%;
			width: auto;
			z-index: 3;
		}

		.main-home__image-mob {
			display: none;
		}

		.main-home__title {
			font-family: var(--third-family);
			font-weight: 400;
			font-size: 44px;
			line-height: 133%;
			text-transform: uppercase;
			color: #fff;
			margin: 0px 0px 30px 0px;
		}

		.main-home__logo {
			width: 523px;
			height: auto;
			margin: 0px 0px 20px 0px;
		}

		.main-home__subtitle {
			font-family: var(--second-family);
			font-weight: 400;
			font-size: 26px;
			line-height: 131%;
			color: rgba(255, 255, 255, 0.7);
			margin: 0px 0px 54px 0px;
		}

		.main-home__buttons {
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-align: center;
			-ms-flex-align: center;
			align-items: center;
			gap: 36px;
		}

		.main-home__buttons span {
			font-family: var(--third-family);
			font-weight: 400;
			font-size: 28px;
			line-height: 117%;
			color: #fff;
		}

		.main-home__button {
			-webkit-box-flex: 1;
			-ms-flex: 1 0 385px;
			flex: 1 0 385px;
		}

		.found {
			padding: 53px 0px 77px 0px;
		}

		.found__header {
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-align: center;
			-ms-flex-align: center;
			align-items: center;
			-webkit-box-pack: center;
			-ms-flex-pack: center;
			justify-content: center;
			margin: 0px 0px 47px 0px;
		}

		.found__header::before,
		.found__header::after {
			content: "";
			width: 50%;
			-webkit-box-flex: 0;
			-ms-flex: 0 1 295px;
			flex: 0 1 295px;
			height: 1px;
			background-color: #000;
		}

		.found__header::before {
			content: "";
			margin: 0px 42px 0px 30px;
		}

		.found__header::after {
			content: "";
			margin: 0px 20px 0px 42px;
		}

		.found__header .title1 {
			-webkit-box-flex: 1;
			-ms-flex: 1 1 auto;
			flex: 1 1 auto;
			line-height: 119%;
			text-align: center;
			color: #313437;
			white-space: nowrap;
		}

		.found__body {
			display: -ms-grid;
			display: grid;
			-webkit-box-align: start;
			-ms-flex-align: start;
			align-items: start;
			-ms-grid-columns: (1fr)[3];
			grid-template-columns: repeat(3, 1fr);
			gap: 30px 40px;
		}

		.found__column {
			position: relative;
			border: 0.92px solid rgba(0, 0, 0, 0.22);
			border-radius: 23px;
			-webkit-box-shadow: 0 5px 6px 0 rgba(0, 0, 0, 0.23);
			box-shadow: 0 5px 6px 0 rgba(0, 0, 0, 0.23);
			background: #fff;
			padding: 20px 25px 27px 25px;
		}

		.found__column p {
			font-family: var(--second-family);
			font-weight: 400;
			font-size: 20px;
			line-height: 141%;
			text-align: center;
			color: #000;
		}

		.found__column p span {
			font-weight: 600;
		}

		.found__number {
			position: absolute;
			top: -1px;
			left: -17px;
			width: 40px;
			height: 40px;
			border-radius: 50%;
			background-color: #ab835f;
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-pack: center;
			-ms-flex-pack: center;
			justify-content: center;
			-webkit-box-align: center;
			-ms-flex-align: center;
			align-items: center;
			text-align: center;
			font-family: var(--second-family);
			font-weight: 600;
			font-size: 17px;
			line-height: 141%;
			color: #fff;
		}

		.found__images {
			position: relative;
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			padding: 10px 20px 10px 20px;
		}

		.found__images span {
			display: none;
			font-family: var(--third-family);
			font-weight: 400;
			font-size: 32px;
			line-height: 119%;
			color: #313437;
			margin: 0px 0px 0px 30px;
		}

		.found__logo {
			max-width: 197px;
			max-height: 197px;
		}

		.found__telegram {
			width: 107px;
			height: 107px;
			margin: 0px 0px 0px -26px;
			-webkit-transition: opacity 0.3s ease;
			-o-transition: opacity 0.3s ease;
			transition: opacity 0.3s ease;
		}

		.found__telegram:hover {
			opacity: 0.8;
		}

		.produce {
			padding: 47px 0px 60px 0px;
			position: relative;
		}

		.produce::before {
			content: "";
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 260px;
			background: #313437;
		}

		.produce__content {
			position: relative;
			z-index: 10;
		}

		.produce__content h2 {
			margin: 0px 0px 40px 0px;
		}

		.produce__item {
			width: 100%;
			-webkit-box-shadow: 0 4px 13px 0 rgba(0, 0, 0, 0.15);
			box-shadow: 0 4px 13px 0 rgba(0, 0, 0, 0.15);
			background: #fff;
			border-radius: 12px;
			padding: 6px;
		}

		.produce__item:hover img {
			-webkit-transform: scale(1.1);
			-ms-transform: scale(1.1);
			transform: scale(1.1);
		}

		.produce__image {
			position: relative;
			overflow: hidden;
		}

		.produce__image img {
			-webkit-transition: -webkit-transform 0.6s ease;
			transition: -webkit-transform 0.6s ease;
			-o-transition: transform 0.6s ease;
			transition: transform 0.6s ease;
			transition: transform 0.6s ease, -webkit-transform 0.6s ease;
			width: 100%;
			height: 418px;
			-o-object-fit: cover;
			object-fit: cover;
			border-radius: 10px;
		}

		.produce__number {
			position: absolute;
			top: 11px;
			left: 11px;
			border-radius: 8px;
			padding: 9px 15px;
			width: 45px;
			height: 45px;
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-pack: center;
			-ms-flex-pack: center;
			justify-content: center;
			-webkit-box-align: center;
			-ms-flex-align: center;
			align-items: center;
			text-align: center;
			font-weight: 400;
			font-size: 28px;
			line-height: 90%;
			color: #fff;
			background: #8d6645;
		}

		.produce__name {
			font-weight: 400;
			font-size: 28px;
			line-height: 90%;
			color: #222;
			padding: 16px 32px 15px 32px;
		}

		.produce__nav {
			display: none;
		}

		.reviews {
			padding: 47px 0px 50px 0px;
			position: relative;
		}

		.reviews::before {
			content: "";
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 260px;
			background: #313437;
		}

		.reviews__content {
			position: relative;
			z-index: 10;
		}

		.reviews__content h2 {
			margin: 0px 0px 15px 0px;
		}

		.reviews__header {
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-pack: justify;
			-ms-flex-pack: justify;
			justify-content: space-between;
			-webkit-box-align: center;
			-ms-flex-align: center;
			align-items: center;
		}

		.reviews__header .title-mob {
			display: none;
		}

		.reviews__nav {
			margin: 0px 0px 0px 20px;
		}

		.reviews__slider {
			position: relative;
			-webkit-clip-path: polygon(0 0, 100vw 0, 100vw 100%, 0 100%);
			clip-path: polygon(0 0, 100vw 0, 100vw 100%, 0 100%);
			margin: 25px -16px;
			width: calc(100% + 32px);
			padding: 0px 16px;
		}

		.reviews__slider.swiper {
			overflow: visible;
		}

		.reviews__slide {
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			min-height: 685px;
		}

		.reviews__item {
			cursor: pointer;
			position: relative;
			-webkit-box-shadow: 0 4px 13px 0 rgba(0, 0, 0, 0.15);
			box-shadow: 0 4px 13px 0 rgba(0, 0, 0, 0.15);
			background: #fff;
			padding: 8px 6px;
			border-radius: 12px;
			height: 100%;
			width: 100%;
		}

		.reviews__item::before {
			content: "";
			-webkit-transition: background-color 0.8s ease 0s;
			-o-transition: background-color 0.8s ease 0s;
			transition: background-color 0.8s ease 0s;
		}

		.reviews__play {
			-webkit-transform: translate(-50%, -50%) translateZ(0);
			transform: translate(-50%, -50%) translateZ(0);
			-webkit-backface-visibility: hidden;
			backface-visibility: hidden;
			-webkit-perspective: 1000px;
			perspective: 1000px;
			will-change: transform;
			cursor: pointer;
			width: 118px;
			height: 118px;
			border-radius: 50%;
			background-color: #ab835f;
			position: absolute;
			top: 50%;
			left: 50%;
			z-index: 10;
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-pack: center;
			-ms-flex-pack: center;
			justify-content: center;
			-webkit-box-align: center;
			-ms-flex-align: center;
			align-items: center;
		}

		.reviews__play svg {
			margin: 0px -5px 0px 0px;
		}

		.reviews__image {
			position: relative;
			height: 100%;
		}

		.reviews__image img {
			width: 100%;
			height: 100%;
			-o-object-fit: cover;
			object-fit: cover;
			border-radius: 10px;
		}

		.reviews__number {
			position: absolute;
			top: 16px;
			left: 16px;
			border-radius: 8px;
			padding: 9px 15px;
			width: 45px;
			height: 45px;
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-pack: center;
			-ms-flex-pack: center;
			justify-content: center;
			-webkit-box-align: center;
			-ms-flex-align: center;
			align-items: center;
			text-align: center;
			font-weight: 400;
			font-size: 28px;
			line-height: 90%;
			color: #fff;
			background: #8d6645;
		}

		.about {
			background: #373737;
			padding: 70px 0px 0px 0px;
		}

		.about__top {
			margin: 0px 0px 80px 0px;
		}

		.top-about {
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-pack: justify;
			-ms-flex-pack: justify;
			justify-content: space-between;
			gap: 0px 57px;
		}

		.top-about__left {
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			height: 100%;
			-webkit-box-orient: vertical;
			-webkit-box-direction: normal;
			-ms-flex-direction: column;
			flex-direction: column;
			-webkit-box-flex: 0;
			-ms-flex: 0 1 660px;
			flex: 0 1 660px;
			border: 7px solid #ab835f;
			position: relative;
		}

		.top-about__bg {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			-o-object-fit: cover;
			object-fit: cover;
			display: none;
		}

		.top-about__title {
			font-family: var(--third-family);
			font-weight: 400;
			font-size: 47px;
			line-height: 118%;
			color: #fff;
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-orient: vertical;
			-webkit-box-direction: normal;
			-ms-flex-direction: column;
			flex-direction: column;
			padding: 33px 48px 27px 48px;
		}

		.top-about__title span {
			color: #ab835f;
		}

		.top-about__image {
			position: relative;
		}

		.top-about__photo {
			width: 578px;
		}

		.top-about__subtitle {
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			position: absolute;
			top: 40px;
			right: 35px;
			font-family: var(--third-family);
			font-weight: 400;
			font-size: 38px;
			line-height: 105%;
			color: #fff;
		}

		.top-about__subtitle span {
			color: #ab835f;
		}

		.top-about__subtitle p {
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-orient: vertical;
			-webkit-box-direction: normal;
			-ms-flex-direction: column;
			flex-direction: column;
			max-width: 258px;
		}

		.top-about__line {
			margin: 0px 15px 0px 0px;
		}

		.top-about__logo {
			position: absolute;
			right: 66px;
			top: 43%;
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-orient: vertical;
			-webkit-box-direction: normal;
			-ms-flex-direction: column;
			flex-direction: column;
		}

		.top-about__logo img {
			width: 167px;
			height: 167px;
			margin: 0px 0px 13px 0px;
		}

		.top-about__logo span {
			font-family: var(--second-family);
			font-weight: 400;
			font-size: 23px;
			line-height: 124%;
			text-align: right;
			color: rgba(255, 255, 255, 0.59);
			margin: 0px 17px 0px 0px;
			display: block;
		}

		.top-about__right {
			-webkit-box-flex: 0;
			-ms-flex: 0 1 444px;
			flex: 0 1 444px;
			margin: 18px 0px 0px 0px;
		}

		.top-about__text {
			margin: 0px 0px 55px 0px;
		}

		.top-about__text:last-child {
			margin: 0px 0px 0px 0px;
		}

		.top-about__text h3 {
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-orient: vertical;
			-webkit-box-direction: normal;
			-ms-flex-direction: column;
			flex-direction: column;
			font-family: var(--third-family);
			font-weight: 400;
			font-size: 40px;
			line-height: 96%;
			color: #fff;
			margin: 0px 0px 20px 0px;
		}

		.top-about__text h3 span {
			color: #ab835f;
		}

		.top-about__text p {
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			font-family: var(--second-family);
			font-weight: 400;
			font-size: 20px;
			line-height: 131%;
			color: rgba(255, 255, 255, 0.7);
			margin: 0px 0px 24px 0px;
		}

		.top-about__text p:last-child {
			margin: 0px 0px 0px 0px;
		}

		.top-about__text p svg {
			-webkit-box-flex: 0;
			-ms-flex: 0 0 61px;
			flex: 0 0 61px;
			margin: 5px 40px 0px 0px;
		}

		.bottom-about {
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			margin: 0px 0px -45px 0px;
		}

		.bottom-about p {
			font-family: var(--font3);
			font-weight: 600;
			font-size: 18px;
			line-height: 138%;
			color: #fff;
			margin: 0px 0px 25px 11px;
			max-width: 250px;
		}

		.bottom-about__left {
			position: relative;
			z-index: 5;
			-webkit-box-flex: 0;
			-ms-flex: 0 1 388px;
			flex: 0 1 388px;
		}

		.bottom-about__title {
			font-family: var(--third-family);
			font-weight: 400;
			font-size: 40px;
			line-height: 105%;
			color: #fff;
			margin: 0px 0px 32px 0px;
		}

		.bottom-about__title span {
			color: #ab835f;
		}

		.bottom-about__subtitle {
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-align: center;
			-ms-flex-align: center;
			align-items: center;
			font-family: var(--second-family);
			font-weight: 400;
			font-size: 22px;
			line-height: 122%;
			color: #c2c2c2;
			max-width: 280px;
			margin: 0px 0px 25px 6px;
		}

		.bottom-about__subtitle img {
			margin: 0px 20px 0px 0px;
		}

		.bottom-about__button {
			width: 100%;
			padding: 23px 10px;
		}

		.bottom-about__center {
			-webkit-box-flex: 0;
			-ms-flex: 0 1 533px;
			flex: 0 1 533px;
			position: relative;
		}

		.bottom-about__book {
			max-width: 535px;
			max-height: 100%;
			margin: -65px 0px 0px -70px;
		}

		.bottom-about__telegram {
			width: 310px;
			height: 310px;
			position: absolute;
			top: -40px;
			right: 0;
		}

		.bottom-about__block {
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-orient: vertical;
			-webkit-box-direction: normal;
			-ms-flex-direction: column;
			flex-direction: column;
			-webkit-box-align: end;
			-ms-flex-align: end;
			align-items: flex-end;
			position: absolute;
			bottom: 210px;
			right: 61px;
		}

		.bottom-about__circle {
			position: relative;
			width: 38px;
			height: 38px;
			background-color: rgba(196, 200, 42, 0.46);
			border-radius: 50%;
			margin: 0px 0px 8px 0px;
		}

		.bottom-about__circle::before {
			content: "";
			position: absolute;
			top: 50%;
			left: 50%;
			-webkit-transform: translate(-50%, -50%);
			-ms-transform: translate(-50%, -50%);
			transform: translate(-50%, -50%);
			width: 18px;
			height: 18px;
			background-color: #c4c82a;
			border-radius: 50%;
		}

		.bottom-about__text {
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-orient: vertical;
			-webkit-box-direction: normal;
			-ms-flex-direction: column;
			flex-direction: column;
			font-family: var(--second-family);
			font-weight: 400;
			font-size: 16px;
			line-height: 144%;
			text-align: right;
			color: rgba(220, 220, 220, 0.8);
		}

		.bottom-about__text span {
			font-weight: 700;
		}

		.bottom-about__arrow {
			position: absolute;
			right: -140px;
			bottom: 135px;
		}

		.bottom-about__right {
			position: relative;
			z-index: 5;
			-webkit-box-flex: 0;
			-ms-flex: 0 1 239px;
			flex: 0 1 239px;
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-orient: vertical;
			-webkit-box-direction: normal;
			-ms-flex-direction: column;
			flex-direction: column;
			-webkit-box-align: center;
			-ms-flex-align: center;
			align-items: center;
		}

		.bottom-about__right img {
			width: 239px;
			height: 239px;
			background: #8d6645;
			padding: 16px;
		}

		.bottom-about__right span {
			font-family: var(--second-family);
			font-weight: 700;
			font-size: 20px;
			line-height: 131%;
			color: rgba(255, 255, 255, 0.7);
			padding: 18px 15px 0px 14px;
		}

		.swiper {
			overflow: hidden;
		}

		.swiper-wrapper {
			width: 100%;
			height: 100%;
			-webkit-box-sizing: content-box;
			box-sizing: content-box;
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			position: relative;
		}

		.swiper-vertical .swiper-wrapper {
			-webkit-box-orient: vertical;
			-webkit-box-direction: normal;
			-ms-flex-direction: column;
			flex-direction: column;
		}

		.swiper-autoheight .swiper-wrapper {
			-webkit-box-align: start;
			-ms-flex-align: start;
			align-items: flex-start;
		}

		.swiper-initialized .swiper-slide {
			-ms-flex-negative: 0;
			flex-shrink: 0;
		}

		.swiper-android .swiper-slide,
		.swiper-android .swiper-wrapper {
			-webkit-transform: translate3d(0px, 0, 0);
			transform: translate3d(0px, 0, 0);
		}

		.swiper-button-lock {
			opacity: 0.5;
		}

		.swiper-button-disabled {
			opacity: 0.5;
		}

		.swiper-pagination-lock {
			opacity: 0.5;
		}

		.swiper-slide-active {
			z-index: 2;
		}

		@media (min-width: 767.98px) {
			.produce__slider.swiper {
				overflow: visible;
			}

			.produce__wrapper {
				display: -ms-grid !important;
				display: grid !important;
				-ms-flex-wrap: wrap;
				flex-wrap: wrap;
				gap: 33px;
			}

			.produce__item {
				height: 100%;
			}
		}

		@media (min-width: 991.98px) {
			.produce__wrapper {
				-ms-grid-columns: (1fr)[3];
				grid-template-columns: repeat(3, 1fr);
			}
		}

		@media (min-width: 1200px) {
			.reviews__slide:nth-child(n+4):not(.swiper-slide-visible) .reviews__item::before {
				content: "";
				pointer-events: none;
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				border-radius: 12px;
				z-index: 15;
				background-color: rgba(255, 255, 255, 0.5);
				-webkit-transition: background-color 0.3s ease 0s;
				-o-transition: background-color 0.3s ease 0s;
				transition: background-color 0.3s ease 0s;
			}
		}

		@media (max-width: 1200px) {
			.main-home__image {
				right: -350px;
			}

			.found__header::before {
				margin: 0px 20px 0px 0px;
			}

			.found__header::after {
				margin: 0px 0px 0px 20px;
			}

			.found__body {
				gap: 30px;
			}

			.reviews__slider {
				margin: 25px -20px;
				width: calc(100% + 40px);
				padding: 0px 20px;
			}

			.about {
				padding: 70px 0px 30px 0px;
			}

			.top-about {
				gap: 0px 20px;
			}

			.top-about__subtitle {
				right: 0px;
			}

			.top-about__logo {
				right: 30px;
			}

			.bottom-about {
				margin: 0px 0px 0px 0px;
			}

			.bottom-about__title {
				font-size: 36px;
			}

			.bottom-about__button {
				width: calc(100% + 50px);
			}

			.bottom-about__center {
				display: -webkit-box;
				display: -ms-flexbox;
				display: flex;
				-webkit-box-pack: center;
				-ms-flex-pack: center;
				justify-content: center;
			}

			.bottom-about__telegram {
				width: 200px;
				height: 200px;
			}

			.bottom-about__block {
				right: 40px;
			}

			.bottom-about__arrow {
				bottom: 15%;
			}
		}

		@media (max-width: 991.98px) {
			.title1 {
				font-size: 36px;
			}

			.title2 {
				font-size: 42px;
			}

			.main-home {
				min-height: 100%;
			}

			.main-home__bg {
				right: auto;
				left: -120%;
			}

			.main-home__content {
				padding: 35px 0px 0px 0px;
				min-height: 100%;
				max-width: 100%;
				display: -webkit-box;
				display: -ms-flexbox;
				display: flex;
				-webkit-box-orient: vertical;
				-webkit-box-direction: normal;
				-ms-flex-direction: column;
				flex-direction: column;
				-webkit-box-align: center;
				-ms-flex-align: center;
				align-items: center;
			}

			.main-home__content h1 {
				text-align: center;
			}

			.main-home__image {
				display: none;
			}

			.main-home__image-mob {
				display: block;
				position: relative;
			}

			.main-home__image-mob img {
				width: 100%;
				height: auto;
			}

			.main-home__image-mob::after {
				content: "";
				position: absolute;
				bottom: 0;
				left: 0;
				width: 100%;
				height: 24%;
				background: -webkit-gradient(linear, left bottom, left top, from(#000), to(rgba(0, 0, 0, 0)));
				background: -o-linear-gradient(bottom, #000 0%, rgba(0, 0, 0, 0) 100%);
				background: linear-gradient(360deg, #000 0%, rgba(0, 0, 0, 0) 100%);
			}

			.main-home__title {
				max-width: 100%;
				font-size: 40px;
				text-align: center;
			}

			.main-home__logo {
				width: 423px;
			}

			.main-home__buttons {
				position: relative;
				z-index: 7;
				-webkit-box-orient: vertical;
				-webkit-box-direction: reverse;
				-ms-flex-direction: column-reverse;
				flex-direction: column-reverse;
				gap: 20px;
				margin: 0px 0px -40px 0px;
			}

			.main-home__buttons span {
				text-align: center;
			}

			.main-home__button {
				-webkit-box-flex: 1;
				-ms-flex: 1 1 auto;
				flex: 1 1 auto;
			}

			.found {
				padding: 75px 0px 77px 0px;
			}

			.found__body {
				-ms-grid-columns: (1fr)[2];
				grid-template-columns: repeat(2, 1fr);
			}

			.reviews__slide {
				min-height: 600px;
			}

			.about__top {
				margin: 0px 0px 44px 0px;
			}

			.top-about {
				-webkit-box-orient: vertical;
				-webkit-box-direction: normal;
				-ms-flex-direction: column;
				flex-direction: column;
				-webkit-box-pack: start;
				-ms-flex-pack: start;
				justify-content: start;
				gap: 30px 0px;
			}

			.top-about__left {
				-webkit-box-flex: 1;
				-ms-flex: 1 1 auto;
				flex: 1 1 auto;
			}

			.top-about__bg {
				display: block;
			}

			.top-about__right {
				-webkit-box-flex: 1;
				-ms-flex: 1 1 auto;
				flex: 1 1 auto;
				margin: 0px 0px 0px 0px;
			}

			.top-about__text {
				border-bottom: 1px solid #fff;
				margin: 0px 0px 34px 0px;
				padding: 0px 0px 36px 0px;
			}

			.top-about__text:last-child {
				margin: 0px 0px 0px 0px;
			}

			.bottom-about__arrow {
				display: none;
			}

			.bottom-about__right {
				-webkit-box-flex: 1;
				-ms-flex: 1 1 auto;
				flex: 1 1 auto;
			}

			.bottom-about__right img {
				display: none;
			}

			.bottom-about__right span {
				display: none;
			}
		}

		@media (max-width: 991.98px) and (max-width: 479.98px) {
			.main-home__image-mob img {
				height: 288px;
				width: auto;
			}
		}

		@media (max-width: 991.98px) and (max-width: 991.98px) {
			.main-home__image-mob::after {
				z-index: 5;
			}
		}

		@media (max-width: 767.98px) {

			.title1 {
				font-size: 26px;
			}

			.title2 {
				font-family: var(--third-family);
				font-size: 34px;
			}

			.nav {
				-webkit-box-pack: justify;
				-ms-flex-pack: justify;
				justify-content: space-between;
				margin: 0px 15px;
			}

			.nav__paginations {
				-ms-flex-wrap: wrap;
				flex-wrap: wrap;
			}

			.pagination-bullets .swiper-pagination-bullet {
				background: #e2e2e2;
			}

			.pagination-bullets .swiper-pagination-bullet-active {
				background: #eac885;
			}

			.pagination-fraction {
				color: rgba(213, 213, 213, 0.7);
			}

			.header {
				background-color: #ab835f;
			}

			.header__content img {
				width: 65px;
				height: 65px;
				margin: 0px 25px 0px 0px;
			}

			.header__content span {
				font-size: 26px;
				max-width: 490px;
			}

			.footer__copy {
				font-size: 18px;
				padding: 29px 0px 35px 0px;
			}

			.main-home__content h1 {
				margin: 0px 0px 10px 0px;
			}

			.main-home__title {
				font-size: 28px;
				margin: 0px 0px 7px 0px;
			}

			.main-home__logo {
				width: 335px;
				margin: 0px 0px 7px 0px;
			}

			.main-home__subtitle {
				font-size: 16px;
				margin: 0px 0px 0px 0px;
				text-align: center;
			}

			.found {
				padding: 65px 0px 36px 0px;
			}

			.found__container {
				padding: 0px 20px 0px 40px;
			}

			.found__header {
				display: none;
			}

			.found__body {
				-ms-grid-columns: 1fr;
				grid-template-columns: 1fr;
				gap: 20px 0px;
			}

			.found__column {
				-webkit-box-ordinal-group: 2;
				-ms-flex-order: 1;
				order: 1;
				padding: 20px 25px 25px 25px;
				border: 0.96px solid rgba(0, 0, 0, 0.22);
				border-radius: 24px;
			}

			.found__column p {
				font-size: 21px;
			}

			.found__number {
				width: 42px;
				height: 42px;
				font-size: 18px;
			}

			.found__images span {
				display: block;
			}

			.found__images {
				padding: 0px 0px 0px 0px;
				-webkit-box-ordinal-group: 0;
				-ms-flex-order: -1;
				order: -1;
				-webkit-box-align: center;
				-ms-flex-align: center;
				align-items: center;
			}

			.found__logo {
				max-width: 131px;
				max-height: 131px;
			}

			.found__telegram {
				display: none;
			}

			.produce {
				padding: 38px 0px 35px 0px;
			}

			.produce::before {
				height: 219px;
			}

			.produce__content h2 {
				margin: 0px 0px 0px 15px;
			}

			.produce__slider {
				margin: 0px -20px;
				width: calc(100% + 40px);
				padding: 0px 20px;
			}

			.produce__slide {
				display: -webkit-box;
				display: -ms-flexbox;
				display: flex;
				height: auto;
			}

			.produce__item {
				margin: 25px 0px;
			}

			.produce__image img {
				height: 408px;
			}

			.produce__number {
				top: 14px;
				left: 14px;
			}

			.produce__name {
				font-size: 27px;
			}

			.produce__nav {
				display: -webkit-box;
				display: -ms-flexbox;
				display: flex;
			}

			.reviews {
				padding: 38px 0px;
			}

			.reviews::before {
				height: 201px;
			}

			.reviews__content h2 {
				margin: 0px 0px 5px 0px;
			}

			.reviews__header {
				margin: 0px 0px 0px 15px;
			}

			.reviews__header .title-pc {
				display: none;
			}

			.reviews__header .title-mob {
				display: block;
			}

			.reviews__nav {
				margin: 0px 0px 0px 0px;
			}

			.reviews__slide {
				min-height: 640px;
			}

			.reviews__play svg {
				width: 44px;
				height: 49px;
			}

			.reviews__play {
				width: 110px;
				height: 110px;
			}

			.about {
				padding: 30px 0px 45px 0px;
			}

			.top-about__title {
				font-size: 31px;
				padding: 21px 20px 5px 22px;
			}

			.top-about__photo {
				width: 95%;
			}

			.top-about__subtitle {
				top: 25px;
				font-size: 24px;
				right: 5px;
			}

			.top-about__subtitle p {
				max-width: 162px;
			}

			.top-about__line {
				margin: 0px 10px 0px 0px;
			}

			.top-about__logo {
				right: 30px;
				top: 40%;
			}

			.top-about__logo img {
				width: 105px;
				height: 105px;
				margin: 0px 0px 10px 0px;
			}

			.top-about__logo span {
				font-size: 14px;
				margin: 0px 15px 0px 0px;
			}

			.bottom-about {
				-webkit-box-orient: vertical;
				-webkit-box-direction: normal;
				-ms-flex-direction: column;
				flex-direction: column;
			}

			.bottom-about p {
				text-align: center;
				margin: 0px 0px 30px 0px;
			}

			.bottom-about__left {
				-webkit-box-flex: 1;
				-ms-flex: 1 1 auto;
				flex: 1 1 auto;
			}

			.bottom-about__title {
				font-size: 40px;
				margin: 0px 0px 20px 0px;
			}

			.bottom-about__button {
				width: 100%;
			}

			.bottom-about__center {
				-webkit-box-flex: 1;
				-ms-flex: 1 1 auto;
				flex: 1 1 auto;
				margin: 0px 0px 15px 0px;
			}

			.bottom-about__telegram {
				top: -20px;
				right: 8%;
			}

			.bottom-about__block {
				right: 5%;
				bottom: 20%;
			}

			.bottom-about__circle {
				margin: 0px 0px 5px 0px;
			}
		}

		@media (max-width: 479.98px) {
			.button {
				padding: 22px;
			}

			.header__content {
				padding: 20px 0px;
			}

			.header__content img {
				width: 45px;
				height: 45px;
				margin: 0px 15px 0px 0px;
			}

			.header__content span {
				font-size: 16px;
				max-width: 300px;
			}

			.main-home__buttons {
				width: 100%;
			}

			.main-home__button {
				width: 100%;
			}

			.bottom-about__book {
				max-width: 350px;
				max-height: 100%;
				margin: -40px 0px 0px -150px;
			}

			.bottom-about__telegram {
				top: -15px;
				right: -2%;
				width: 230px;
				height: 230px;
			}

			.bottom-about__block {
				right: 8%;
				bottom: 4%;
			}

			.bottom-about__text br {
				display: none;
			}
		}

		@media (max-width: 430px) {
			.button {
				font-size: 18px;
			}

			.nav {
				margin: 0px 0px 0px 0px;
			}

			.main-home__logo {
				width: 280px;
			}

			.main-home__buttons span {
				font-size: 20px;
			}

			.found__images span {
				font-size: 24px;
				margin: 0px 0px 0px 20px;
			}

			.found__logo {
				max-width: 100px;
				max-height: 100px;
			}

			.produce__image img {
				height: 340px;
			}

			.reviews__slide {
				min-height: 500px;
			}

			.top-about__title {
				font-size: 24px;
				padding: 10px 10px 5px 10px;
			}

			.top-about__photo {
				width: 100%;
			}

			.top-about__subtitle {
				font-size: 18px;
				right: 10px;
			}

			.top-about__subtitle p {
				max-width: 100px;
			}

			.top-about__logo {
				right: 10px;
			}

			.top-about__logo img {
				width: 80px;
				height: 80px;
				margin: 0px 0px 5px 0px;
			}

			.top-about__logo span {
				font-size: 12px;
			}

			.top-about__text h3 {
				font-size: 34px;
			}

			.top-about__text p svg {
				-webkit-box-flex: 0;
				-ms-flex: 0 0 50px;
				flex: 0 0 50px;
				margin: 0px 20px 0px 0px;
			}

			.top-about__text p {
				font-size: 16px;
			}

			.bottom-about__book {
				margin: -40px 0px 0px -50px;
			}

			.bottom-about__telegram {
				width: 150px;
				height: 150px;
			}
		}

		@media (max-width: 991.98px) and (min-width: 767.98px) {
			.produce__wrapper {
				-ms-grid-columns: (1fr)[2];
				grid-template-columns: repeat(2, 1fr);
			}
		}
	</style>
</head>

<body>
	<div class="wrapper">
		<header class="header">
			<div class="header__container">
				<a href="#" class="header__content">
					<img src="img/icons/telegram2.svg" alt="">
					<span>
						Подписаться, забирать каталог лучших работ и закрепить скидку 5%
					</span>
				</a>
			</div>
		</header>
		<main class="page">
			<div class="main-home">
				<div class="main-home__container">
					<picture>
						<source srcset="img/main-home-bg.webp" type="image/webp"><img src="img/main-home-bg.png" alt=""
							class="main-home__bg">
					</picture>
					<picture>
						<source srcset="img/main-home-image.webp" type="image/webp"><img src="img/main-home-image.png"
							alt="" class="main-home__image">
					</picture>
					<div class="main-home__content">
						<div class="main-home__title">Telegram-канал</div>
						<img class="main-home__logo" src="img/icons/logo.svg" alt="">
						<h1 class="title1">
							Искусство ковки, литья и столярного дела
						</h1>
						<div class="main-home__subtitle">
							С доставкой и монтажом по всей России
						</div>
						<div class="main-home__image-mob">
							<picture>
								<source srcset="img/main-home-image.webp" type="image/webp"><img
									src="img/main-home-image.png" alt="" class="">
							</picture>
						</div>
						<div class="main-home__buttons">
							<a href="#" class="main-home__button button">Перейти в наш TG-канал</a>
							<span>Подписчикам скидка 5%</span>
						</div>
					</div>
				</div>
			</div>
			<div class="found">
				<div class="found__container">
					<div class="found__content">
						<div class="found__header">
							<h2 class="title1">В канале вы найдете</h2>
						</div>
						<div class="found__body">
							<div class="found__column">
								<div class="found__number">1</div>
								<p>
									<span>Более 2000 видов:</span>
									<br>
									авторских и дизайнерских работ и идей для реализации своего
									проекта, каталог с ценами в закрепленном посте
								</p>
							</div>
							<div class="found__column">
								<div class="found__number">2</div>
								<p>
									<span>Экспертный контент -</span>
									<br>
									фото и видео от изготовления до монтажа, выбора материалов и недопустить ошибок при
									выборе
								</p>
							</div>
							<div class="found__column">
								<div class="found__number">3</div>
								<p>
									<span>Производственный процесс:</span>
									<br>
									полный цикл изготовления, высокий уровень мастерства и
									безупречное качество наших изделий
								</p>
							</div>
							<div class="found__column">
								<div class="found__number">4</div>
								<p>
									<span>Контактную информацию:</span>
									<br>
									Telegram, WhatsApp, Email и личное общение с менеджером
								</p>
							</div>
							<div class="found__column">
								<div class="found__number">5</div>
								<p>
									<span>Эксклюзивный блог владельца “КовАрт”:</span> здесь вы найдете только то, что
									скрыто за кулисами. Личный опыт, секреты мастерства, которые не публикуются в сети
								</p>
							</div>
							<div class="found__images">
								<picture>
									<source srcset="img/logo.webp" type="image/webp"><img loading="lazy"
										src="img/logo.png" alt="" class="found__logo">
								</picture>
								<span>
									В канале вы найдете материалы
								</span>
								<a href="#">
									<img loading="lazy" src="img/icons/telegram.svg" alt="" class="found__telegram">
								</a>
							</div>
						</div>
					</div>
				</div>
			</div>
			<div class="produce">
				<div class="produce__container">
					<div class="produce__content">
						<h2 class="title2">Что мы производим:</h2>
						<div class="produce__body">
							<div class="produce__slider swiper">
								<div class="produce__wrapper swiper-wrapper">
									<a href="#" class="produce__slide swiper-slide">
										<div class="produce__item">
											<div class="produce__image">
												<picture>
													<source srcset="img/produce/image1.webp" type="image/webp"><img
														loading="lazy" src="img/produce/image1.png" alt="">
												</picture>
												<div class="produce__number">1</div>
											</div>
											<div class="produce__name">Козырьки</div>
										</div>
									</a>
									<a href="#" class="produce__slide swiper-slide">
										<div class="produce__item">
											<div class="produce__image">
												<picture>
													<source srcset="img/produce/image2.webp" type="image/webp"><img
														loading="lazy" src="img/produce/image2.png" alt="">
												</picture>
												<div class="produce__number">2</div>
											</div>
											<div class="produce__name">Перила</div>
										</div>
									</a>
									<a href="#" class="produce__slide swiper-slide">
										<div class="produce__item">
											<div class="produce__image">
												<picture>
													<source srcset="img/produce/image3.webp" type="image/webp"><img
														loading="lazy" src="img/produce/image3.png" alt="">
												</picture>
												<div class="produce__number">3</div>
											</div>
											<div class="produce__name">Ворота</div>
										</div>
									</a>
									<a href="#" class="produce__slide swiper-slide">
										<div class="produce__item">
											<div class="produce__image">
												<picture>
													<source srcset="img/produce/image4.webp" type="image/webp"><img
														loading="lazy" src="img/produce/image4.png" alt="">
												</picture>
												<div class="produce__number">4</div>
											</div>
											<div class="produce__name">Калитки</div>
										</div>
									</a>
									<a href="#" class="produce__slide swiper-slide">
										<div class="produce__item">
											<div class="produce__image">
												<picture>
													<source srcset="img/produce/image5.webp" type="image/webp"><img
														loading="lazy" src="img/produce/image5.png" alt="">
												</picture>
												<div class="produce__number">5</div>
											</div>
											<div class="produce__name">Балконные перила</div>
										</div>
									</a>
									<a href="#" class="produce__slide swiper-slide">
										<div class="produce__item">
											<div class="produce__image">
												<picture>
													<source srcset="img/produce/image6.webp" type="image/webp"><img
														loading="lazy" src="img/produce/image6.png" alt="">
												</picture>
												<div class="produce__number">6</div>
											</div>
											<div class="produce__name">Беседки</div>
										</div>
									</a>
									<a href="#" class="produce__slide swiper-slide">
										<div class="produce__item">
											<div class="produce__image">
												<picture>
													<source srcset="img/produce/image7.webp" type="image/webp"><img
														loading="lazy" src="img/produce/image7.png" alt="">
												</picture>
												<div class="produce__number">7</div>
											</div>
											<div class="produce__name">Балясины</div>
										</div>
									</a>
									<a href="#" class="produce__slide swiper-slide">
										<div class="produce__item">
											<div class="produce__image">
												<picture>
													<source srcset="img/produce/image8.webp" type="image/webp"><img
														loading="lazy" src="img/produce/image8.png" alt="">
												</picture>
												<div class="produce__number">8</div>
											</div>
											<div class="produce__name">Двери</div>
										</div>
									</a>
									<a href="#" class="produce__slide swiper-slide">
										<div class="produce__item">
											<div class="produce__image">
												<picture>
													<source srcset="img/produce/image9.webp" type="image/webp"><img
														loading="lazy" src="img/produce/image9.png" alt="">
												</picture>
												<div class="produce__number">9</div>
											</div>
											<div class="produce__name">Лестницы</div>
										</div>
									</a>
									<a href="#" class="produce__slide swiper-slide">
										<div class="produce__item">
											<div class="produce__image">
												<picture>
													<source srcset="img/produce/image10.webp" type="image/webp"><img
														loading="lazy" src="img/produce/image10.png" alt="">
												</picture>
												<div class="produce__number">10</div>
											</div>
											<div class="produce__name">Мостики</div>
										</div>
									</a>
									<a href="#" class="produce__slide swiper-slide">
										<div class="produce__item">
											<div class="produce__image">
												<picture>
													<source srcset="img/produce/image11.webp" type="image/webp"><img
														loading="lazy" src="img/produce/image11.png" alt="">
												</picture>
												<div class="produce__number">11</div>
											</div>
											<div class="produce__name">Навесы</div>
										</div>
									</a>
									<a href="#" class="produce__slide swiper-slide">
										<div class="produce__item">
											<div class="produce__image">
												<picture>
													<source srcset="img/produce/image12.webp" type="image/webp"><img
														loading="lazy" src="img/produce/image12.png" alt="">
												</picture>
												<div class="produce__number">12</div>
											</div>
											<div class="produce__name">Заборы</div>
										</div>
									</a>
								</div>
							</div>
							<div class="produce__nav nav">
								<div class="nav__paginations">
									<div class="produce__pagination-bullets pagination-bullets"></div>
									<div class="produce__pagination-fraction pagination-fraction">
										<span class="swiper-pagination-current">1</span>
										/
										<span class="swiper-pagination-total"></span>
									</div>
								</div>
								<div class="nav__arrows">
									<div class="produce__arrow-prev arrow-prev">
										<svg width="10" height="18" viewBox="0 0 10 18" fill="none"
											xmlns="http://www.w3.org/2000/svg">
											<path d="M9.22183 1.22182L1.44365 9L9.22182 16.7782" stroke="white"
												stroke-width="2" />
										</svg>
									</div>
									<div class="produce__arrow-next arrow-next">
										<svg width="10" height="18" viewBox="0 0 10 18" fill="none"
											xmlns="http://www.w3.org/2000/svg">
											<path d="M0.778174 1.22182L8.55635 9L0.778176 16.7782" stroke="white"
												stroke-width="2" />
										</svg>
									</div>
								</div>
							</div>
						</div>
					</div>
				</div>
			</div>
			<div class="reviews">
				<div class="reviews__container">
					<div class="reviews__content">
						<div class="reviews__header">
							<h2 class="title2">
								<span class="title-pc">Наши обзоры и отзывы</span>
								<span class="title-mob">Наш видео-контент:</span>
							</h2>
							<div data-da=".reviews__body, 767.98" class="reviews__nav nav">
								<div class="nav__paginations">
									<div class="reviews__pagination-bullets pagination-bullets"></div>
									<div class="reviews__pagination-fraction pagination-fraction">
										<span class="swiper-pagination-current">1</span>
										/
										<span class="swiper-pagination-total"></span>
									</div>
								</div>
								<div class="nav__arrows">
									<div class="reviews__arrow-prev arrow-prev">
										<svg width="10" height="18" viewBox="0 0 10 18" fill="none"
											xmlns="http://www.w3.org/2000/svg">
											<path d="M9.22183 1.22182L1.44365 9L9.22182 16.7782" stroke="white"
												stroke-width="2" />
										</svg>
									</div>
									<div class="reviews__arrow-next arrow-next">
										<svg width="10" height="18" viewBox="0 0 10 18" fill="none"
											xmlns="http://www.w3.org/2000/svg">
											<path d="M0.778174 1.22182L8.55635 9L0.778176 16.7782" stroke="white"
												stroke-width="2" />
										</svg>
									</div>
								</div>
							</div>
						</div>
						<div class="reviews__body">
							<div class="reviews__slider swiper">
								<div class="reviews__wrapper swiper-wrapper">
									<div class="reviews__slide swiper-slide">
										<div data-popup="#video1" class="reviews__item">
											<div class="reviews__image">
												<div class="reviews__play">
													<svg width="47" height="53" viewBox="0 0 47 53" fill="none"
														xmlns="http://www.w3.org/2000/svg">
														<path
															d="M41.9503 18.7593C47.8283 22.246 47.8283 30.754 41.9503 34.2407L13.8415 50.9139C7.84215 54.4725 0.249997 50.1486 0.249998 43.1732L0.249999 9.82677C0.249999 2.85136 7.84214 -1.47254 13.8415 2.0861L41.9503 18.7593Z"
															fill="white" />
													</svg>
												</div>
												<picture>
													<source srcset="img/produce/image1.webp" type="image/webp"><img
														loading="lazy" src="img/produce/image1.png" alt="">
												</picture>
												<div class="reviews__number">1</div>
											</div>
										</div>
									</div>
									<div class="reviews__slide swiper-slide">
										<div data-popup="#video2" class="reviews__item">
											<div class="reviews__image">
												<div class="reviews__play">
													<svg width="47" height="53" viewBox="0 0 47 53" fill="none"
														xmlns="http://www.w3.org/2000/svg">
														<path
															d="M41.9503 18.7593C47.8283 22.246 47.8283 30.754 41.9503 34.2407L13.8415 50.9139C7.84215 54.4725 0.249997 50.1486 0.249998 43.1732L0.249999 9.82677C0.249999 2.85136 7.84214 -1.47254 13.8415 2.0861L41.9503 18.7593Z"
															fill="white" />
													</svg>
												</div>
												<picture>
													<source srcset="img/produce/image1.webp" type="image/webp"><img
														loading="lazy" src="img/produce/image1.png" alt="">
												</picture>
												<div class="reviews__number">2</div>
											</div>
										</div>
									</div>
									<div class="reviews__slide swiper-slide">
										<div data-popup="#video3" class="reviews__item">
											<div class="reviews__image">
												<div class="reviews__play">
													<svg width="47" height="53" viewBox="0 0 47 53" fill="none"
														xmlns="http://www.w3.org/2000/svg">
														<path
															d="M41.9503 18.7593C47.8283 22.246 47.8283 30.754 41.9503 34.2407L13.8415 50.9139C7.84215 54.4725 0.249997 50.1486 0.249998 43.1732L0.249999 9.82677C0.249999 2.85136 7.84214 -1.47254 13.8415 2.0861L41.9503 18.7593Z"
															fill="white" />
													</svg>
												</div>
												<picture>
													<source srcset="img/produce/image1.webp" type="image/webp"><img
														loading="lazy" src="img/produce/image1.png" alt="">
												</picture>
												<div class="reviews__number">3</div>
											</div>
										</div>
									</div>
									<div class="reviews__slide swiper-slide">
										<div data-popup="#video4" class="reviews__item">
											<div class="reviews__image">
												<div class="reviews__play">
													<svg width="47" height="53" viewBox="0 0 47 53" fill="none"
														xmlns="http://www.w3.org/2000/svg">
														<path
															d="M41.9503 18.7593C47.8283 22.246 47.8283 30.754 41.9503 34.2407L13.8415 50.9139C7.84215 54.4725 0.249997 50.1486 0.249998 43.1732L0.249999 9.82677C0.249999 2.85136 7.84214 -1.47254 13.8415 2.0861L41.9503 18.7593Z"
															fill="white" />
													</svg>
												</div>
												<picture>
													<source srcset="img/produce/image1.webp" type="image/webp"><img
														loading="lazy" src="img/produce/image1.png" alt="">
												</picture>
												<div class="reviews__number">4</div>
											</div>
										</div>
									</div>
									<div class="reviews__slide swiper-slide">
										<div data-popup="#video5" class="reviews__item">
											<div class="reviews__image">
												<div class="reviews__play">
													<svg width="47" height="53" viewBox="0 0 47 53" fill="none"
														xmlns="http://www.w3.org/2000/svg">
														<path
															d="M41.9503 18.7593C47.8283 22.246 47.8283 30.754 41.9503 34.2407L13.8415 50.9139C7.84215 54.4725 0.249997 50.1486 0.249998 43.1732L0.249999 9.82677C0.249999 2.85136 7.84214 -1.47254 13.8415 2.0861L41.9503 18.7593Z"
															fill="white" />
													</svg>
												</div>
												<picture>
													<source srcset="img/produce/image1.webp" type="image/webp"><img
														loading="lazy" src="img/produce/image1.png" alt="">
												</picture>
												<div class="reviews__number">5</div>
											</div>
										</div>
									</div>
									<div class="reviews__slide swiper-slide">
										<div data-popup="#video6" class="reviews__item">
											<div class="reviews__image">
												<div class="reviews__play">
													<svg width="47" height="53" viewBox="0 0 47 53" fill="none"
														xmlns="http://www.w3.org/2000/svg">
														<path
															d="M41.9503 18.7593C47.8283 22.246 47.8283 30.754 41.9503 34.2407L13.8415 50.9139C7.84215 54.4725 0.249997 50.1486 0.249998 43.1732L0.249999 9.82677C0.249999 2.85136 7.84214 -1.47254 13.8415 2.0861L41.9503 18.7593Z"
															fill="white" />
													</svg>
												</div>
												<picture>
													<source srcset="img/produce/image1.webp" type="image/webp"><img
														loading="lazy" src="img/produce/image1.png" alt="">
												</picture>
												<div class="reviews__number">6</div>
											</div>
										</div>
									</div>
									<div class="reviews__slide swiper-slide">
										<div data-popup="#video7" class="reviews__item">
											<div class="reviews__image">
												<div class="reviews__play">
													<svg width="47" height="53" viewBox="0 0 47 53" fill="none"
														xmlns="http://www.w3.org/2000/svg">
														<path
															d="M41.9503 18.7593C47.8283 22.246 47.8283 30.754 41.9503 34.2407L13.8415 50.9139C7.84215 54.4725 0.249997 50.1486 0.249998 43.1732L0.249999 9.82677C0.249999 2.85136 7.84214 -1.47254 13.8415 2.0861L41.9503 18.7593Z"
															fill="white" />
													</svg>
												</div>
												<picture>
													<source srcset="img/produce/image1.webp" type="image/webp"><img
														loading="lazy" src="img/produce/image1.png" alt="">
												</picture>
												<div class="reviews__number">7</div>
											</div>
										</div>
									</div>
									<div class="reviews__slide swiper-slide">
										<div data-popup="#video8" class="reviews__item">
											<div class="reviews__image">
												<div class="reviews__play">
													<svg width="47" height="53" viewBox="0 0 47 53" fill="none"
														xmlns="http://www.w3.org/2000/svg">
														<path
															d="M41.9503 18.7593C47.8283 22.246 47.8283 30.754 41.9503 34.2407L13.8415 50.9139C7.84215 54.4725 0.249997 50.1486 0.249998 43.1732L0.249999 9.82677C0.249999 2.85136 7.84214 -1.47254 13.8415 2.0861L41.9503 18.7593Z"
															fill="white" />
													</svg>
												</div>
												<picture>
													<source srcset="img/produce/image1.webp" type="image/webp"><img
														loading="lazy" src="img/produce/image1.png" alt="">
												</picture>
												<div class="reviews__number">8</div>
											</div>
										</div>
									</div>
									<div class="reviews__slide swiper-slide">
										<div data-popup="#video9" class="reviews__item">
											<div class="reviews__image">
												<div class="reviews__play">
													<svg width="47" height="53" viewBox="0 0 47 53" fill="none"
														xmlns="http://www.w3.org/2000/svg">
														<path
															d="M41.9503 18.7593C47.8283 22.246 47.8283 30.754 41.9503 34.2407L13.8415 50.9139C7.84215 54.4725 0.249997 50.1486 0.249998 43.1732L0.249999 9.82677C0.249999 2.85136 7.84214 -1.47254 13.8415 2.0861L41.9503 18.7593Z"
															fill="white" />
													</svg>
												</div>
												<picture>
													<source srcset="img/produce/image1.webp" type="image/webp"><img
														loading="lazy" src="img/produce/image1.png" alt="">
												</picture>
												<div class="reviews__number">9</div>
											</div>
										</div>
									</div>
									<div class="reviews__slide swiper-slide">
										<div data-popup="#video10" class="reviews__item">
											<div class="reviews__image">
												<div class="reviews__play">
													<svg width="47" height="53" viewBox="0 0 47 53" fill="none"
														xmlns="http://www.w3.org/2000/svg">
														<path
															d="M41.9503 18.7593C47.8283 22.246 47.8283 30.754 41.9503 34.2407L13.8415 50.9139C7.84215 54.4725 0.249997 50.1486 0.249998 43.1732L0.249999 9.82677C0.249999 2.85136 7.84214 -1.47254 13.8415 2.0861L41.9503 18.7593Z"
															fill="white" />
													</svg>
												</div>
												<picture>
													<source srcset="img/produce/image1.webp" type="image/webp"><img
														loading="lazy" src="img/produce/image1.png" alt="">
												</picture>
												<div class="reviews__number">10</div>
											</div>
										</div>
									</div>
									<div class="reviews__slide swiper-slide">
										<div data-popup="#video11" class="reviews__item">
											<div class="reviews__image">
												<div class="reviews__play">
													<svg width="47" height="53" viewBox="0 0 47 53" fill="none"
														xmlns="http://www.w3.org/2000/svg">
														<path
															d="M41.9503 18.7593C47.8283 22.246 47.8283 30.754 41.9503 34.2407L13.8415 50.9139C7.84215 54.4725 0.249997 50.1486 0.249998 43.1732L0.249999 9.82677C0.249999 2.85136 7.84214 -1.47254 13.8415 2.0861L41.9503 18.7593Z"
															fill="white" />
													</svg>
												</div>
												<picture>
													<source srcset="img/produce/image1.webp" type="image/webp"><img
														loading="lazy" src="img/produce/image1.png" alt="">
												</picture>
												<div class="reviews__number">11</div>
											</div>
										</div>
									</div>
									<div class="reviews__slide swiper-slide">
										<div data-popup="#video12" class="reviews__item">
											<div class="reviews__image">
												<div class="reviews__play">
													<svg width="47" height="53" viewBox="0 0 47 53" fill="none"
														xmlns="http://www.w3.org/2000/svg">
														<path
															d="M41.9503 18.7593C47.8283 22.246 47.8283 30.754 41.9503 34.2407L13.8415 50.9139C7.84215 54.4725 0.249997 50.1486 0.249998 43.1732L0.249999 9.82677C0.249999 2.85136 7.84214 -1.47254 13.8415 2.0861L41.9503 18.7593Z"
															fill="white" />
													</svg>
												</div>
												<picture>
													<source srcset="img/produce/image1.webp" type="image/webp"><img
														loading="lazy" src="img/produce/image1.png" alt="">
												</picture>
												<div class="reviews__number">12</div>
											</div>
										</div>
									</div>
									<div class="reviews__slide swiper-slide">
										<div data-popup="#video13" class="reviews__item">
											<div class="reviews__image">
												<div class="reviews__play">
													<svg width="47" height="53" viewBox="0 0 47 53" fill="none"
														xmlns="http://www.w3.org/2000/svg">
														<path
															d="M41.9503 18.7593C47.8283 22.246 47.8283 30.754 41.9503 34.2407L13.8415 50.9139C7.84215 54.4725 0.249997 50.1486 0.249998 43.1732L0.249999 9.82677C0.249999 2.85136 7.84214 -1.47254 13.8415 2.0861L41.9503 18.7593Z"
															fill="white" />
													</svg>
												</div>
												<picture>
													<source srcset="img/produce/image1.webp" type="image/webp"><img
														loading="lazy" src="img/produce/image1.png" alt="">
												</picture>
												<div class="reviews__number">13</div>
											</div>
										</div>
									</div>
									<div class="reviews__slide swiper-slide">
										<div data-popup="#video14" class="reviews__item">
											<div class="reviews__image">
												<div class="reviews__play">
													<svg width="47" height="53" viewBox="0 0 47 53" fill="none"
														xmlns="http://www.w3.org/2000/svg">
														<path
															d="M41.9503 18.7593C47.8283 22.246 47.8283 30.754 41.9503 34.2407L13.8415 50.9139C7.84215 54.4725 0.249997 50.1486 0.249998 43.1732L0.249999 9.82677C0.249999 2.85136 7.84214 -1.47254 13.8415 2.0861L41.9503 18.7593Z"
															fill="white" />
													</svg>
												</div>
												<picture>
													<source srcset="img/produce/image1.webp" type="image/webp"><img
														loading="lazy" src="img/produce/image1.png" alt="">
												</picture>
												<div class="reviews__number">14</div>
											</div>
										</div>
									</div>
									<div class="reviews__slide swiper-slide">
										<div data-popup="#video15" class="reviews__item">
											<div class="reviews__image">
												<div class="reviews__play">
													<svg width="47" height="53" viewBox="0 0 47 53" fill="none"
														xmlns="http://www.w3.org/2000/svg">
														<path
															d="M41.9503 18.7593C47.8283 22.246 47.8283 30.754 41.9503 34.2407L13.8415 50.9139C7.84215 54.4725 0.249997 50.1486 0.249998 43.1732L0.249999 9.82677C0.249999 2.85136 7.84214 -1.47254 13.8415 2.0861L41.9503 18.7593Z"
															fill="white" />
													</svg>
												</div>
												<picture>
													<source srcset="img/produce/image1.webp" type="image/webp"><img
														loading="lazy" src="img/produce/image1.png" alt="">
												</picture>
												<div class="reviews__number">15</div>
											</div>
										</div>
									</div>
								</div>
							</div>
						</div>
					</div>
				</div>
			</div>
			<div class="about">
				<div class="about__container">
					<div class="about__content">
						<div class="about__top top-about">
							<div class="top-about__left">
								<picture>
									<source srcset="img/bg.webp" type="image/webp"><img loading="lazy" src="img/bg.png"
										alt="" class="top-about__bg">
								</picture>
								<div class="top-about__title">
									<span>Здравствуйте,</span>
									я Калганов Виталий,<br> владелец “КовАрт”
								</div>
								<div class="top-about__image">
									<picture>
										<source srcset="img/photo.webp" type="image/webp"><img loading="lazy"
											src="img/photo.png" alt="" class="top-about__photo">
									</picture>
									<div class="top-about__subtitle">
										<div class="top-about__line">—</div>
										<p>
											Результат под моим <span>личным контролем!</span>
										</p>
									</div>
									<div class="top-about__logo">
										<picture>
											<source srcset="img/logo.webp" type="image/webp"><img loading="lazy"
												src="img/logo.png" alt="" class="">
										</picture>
										<span>
											Работаем
											<br>
											с 1994 г
										</span>
									</div>
								</div>
							</div>
							<div class="top-about__right">
								<div class="top-about__text">
									<p>
										<svg width="61" height="68" viewBox="0 0 61 68" fill="none"
											xmlns="http://www.w3.org/2000/svg">
											<path
												d="M60.5134 9.14124L57.6169 6.58252L60.5134 4.02432C60.9639 3.62589 61.118 3.00488 60.9065 2.44147C60.6939 1.87753 60.169 1.51334 59.5686 1.51334H47.5822V0.996612C47.5822 0.446167 47.1374 0 46.5887 0C46.0401 0 45.5953 0.446167 45.5953 0.996612V14.4377L37.4363 18.8822C37.3913 18.5222 37.2837 18.1683 37.1136 17.8353L35.964 15.5837C35.1748 14.0377 33.2789 13.425 31.7389 14.2161L30.8499 14.6727C30.1031 15.0566 29.5503 15.7082 29.2928 16.5092C29.0352 17.3097 29.104 18.1631 29.4867 18.9118L30.6363 21.1639C30.9047 21.6894 31.3014 22.1055 31.7678 22.3971C31.1576 23.2214 30.868 24.2352 30.5701 25.2883L30.356 26.0489C30.2066 26.5786 30.5137 27.1295 31.0418 27.279C31.1317 27.3049 31.2228 27.3168 31.3122 27.3168C31.7456 27.3168 32.1438 27.0305 32.2679 26.591L32.482 25.832C32.9174 24.2917 33.1848 23.4668 34.036 23.003L35.5621 22.1714L35.7504 22.0749C35.813 22.0427 35.8714 22.0064 35.9309 21.9706L46.8075 16.0454C46.7387 17.4093 46.007 18.698 44.802 19.4321L37.729 23.7433C37.7207 23.748 37.7124 23.7527 37.7047 23.7579L35.5032 25.0995C35.0346 25.3853 34.8852 25.9986 35.1701 26.4691C35.4385 26.9127 35.9971 27.0704 36.4527 26.8478L34.7823 31.9134L33.5613 32.4156L30.2412 33.7805L31.1979 30.3876C31.3469 29.8579 31.0402 29.3069 30.5122 29.157C29.9837 29.0066 29.435 29.3152 29.2855 29.8449L27.7739 35.2078C27.7542 35.2768 27.7413 35.3525 27.7382 35.4246L27.3426 42.7148C27.3307 42.9929 27.3897 43.5184 27.2614 43.7897L22.8677 53.0627H19.6749C17.8043 53.0627 16.2829 54.5891 16.2829 56.465V59.3418C15.8547 59.1451 15.3794 59.0352 14.8783 59.0352H6.76997C4.89997 59.0352 3.37852 60.5609 3.37852 62.4374V66.0068H0.993439C0.444746 66.0068 0 66.4529 0 67.0034C0 67.5538 0.444746 68 0.993439 68H59.5676C60.1163 68 60.561 67.5538 60.561 67.0034C60.561 66.4529 60.1163 66.0068 59.5676 66.0068H56.9839V40.3185C56.9839 38.4425 55.4625 36.9162 53.5925 36.9162H47.5822V19.5297C48.6837 18.0319 49.0917 16.0688 48.5803 14.2032C48.5001 13.91 48.2907 13.6693 48.0114 13.5505C47.8744 13.4919 47.7275 13.4659 47.5822 13.4716V11.6522H59.5681C60.169 11.6522 60.6939 11.288 60.906 10.7246C61.118 10.1612 60.9639 9.53967 60.5134 9.14124ZM31.184 17.1214C31.2786 16.8272 31.4813 16.5876 31.7554 16.447L32.6444 15.9904C32.8119 15.9043 32.9909 15.8633 33.1677 15.8633C33.5866 15.8633 33.9916 16.0931 34.1953 16.4921L35.3455 18.7442C35.6138 19.2703 35.4401 19.9079 34.9628 20.23L34.639 20.4059L33.9559 20.7571C33.3906 21.0477 32.6946 20.8225 32.405 20.2549L31.2548 18.0034C31.1147 17.7284 31.0893 17.415 31.184 17.1214ZM29.1878 53.3694C28.8501 53.2148 28.4829 53.1136 28.0971 53.0778L29.1878 51.6246V53.3694ZM33.9047 45.3389C34.3825 44.7646 34.5144 44.0938 34.6209 43.5532C34.6478 43.4245 35.1381 40.7382 35.1381 40.7382C35.1381 40.7382 35.602 41.0282 35.6506 41.0489C35.6842 41.064 35.708 41.0972 35.7116 41.1361L36.252 46.6473H32.9226L33.9047 45.3389ZM39.7795 39.838L38.9407 46.6426H38.2482L37.6892 40.941C37.6178 40.2105 37.172 39.5729 36.5189 39.256L35.5197 38.6204L36.1853 34.9198C36.1853 34.9198 38.9893 38.2614 39.0544 38.3465C39.6347 39.1034 39.8333 39.4064 39.7795 39.838ZM29.0487 44.6613C29.2493 44.0554 29.3424 43.4385 29.3269 42.8113L29.6879 36.1624L34.2827 34.2734L33.4475 38.9146C33.4449 38.927 33.4423 38.94 33.4408 38.9525L32.7499 42.79C32.6599 43.1874 32.5813 43.7903 32.3341 44.1176L25.621 53.0627H25.0677L29.0487 44.6613ZM5.3654 62.4369C5.3654 61.6603 5.99529 61.0284 6.76997 61.0284H14.8783C15.653 61.0284 16.2834 61.6603 16.2834 62.4369V66.0068H5.3654V62.4369ZM18.2698 62.4369V56.465C18.2698 55.6879 18.9002 55.056 19.6749 55.056H27.7832C28.5579 55.056 29.1878 55.6879 29.1878 56.465V66.0068H18.2703V62.4369H18.2698ZM54.997 40.3185V66.0068H44.0795V60.0312C44.0795 59.4808 43.6348 59.0346 43.0861 59.0346C42.5369 59.0346 42.0922 59.4808 42.0922 60.0312V66.0068H31.1747V50.049C31.1747 49.2724 31.8045 48.6405 32.5792 48.6405H40.6876C41.4623 48.6405 42.0922 49.2724 42.0922 50.049V55.0451C42.0922 55.5955 42.5369 56.0417 43.0856 56.0417C43.6348 56.0417 44.079 55.5955 44.079 55.0451V40.3185C44.079 39.5413 44.7094 38.9094 45.4841 38.9094H46.5784C46.5815 38.9094 46.5851 38.9099 46.5887 38.9099C46.5918 38.9099 46.5955 38.9094 46.5986 38.9094H53.5919C54.3666 38.9094 54.997 39.5418 54.997 40.3185ZM45.4841 36.9162C43.6141 36.9162 42.0927 38.4425 42.0927 40.3185V46.9539C41.7369 46.791 41.349 46.6877 40.941 46.6577L41.7514 40.0834C41.9106 38.802 41.259 37.9527 40.6291 37.131C40.5624 37.0438 36.7009 32.4441 36.7009 32.4441L39.0699 25.2588L45.5953 21.2816V36.9162H45.4841ZM47.5822 9.65848V3.50708H58.0922L55.8286 5.50653C55.5204 5.7789 55.3435 6.17111 55.3435 6.58304C55.3435 6.99496 55.5204 7.38718 55.8286 7.65955L58.0922 9.659H47.5822V9.65848Z"
												fill="white" />
										</svg>
										Наша работа — это не просто услуги, а комфорт и уверенность для клиента
									</p>
									<p>
										Благодаря собственному производству, мы держим под контролем каждый этап: от
										сроков до бюджета.
									</p>
									<p>
										Всё чётко и прозрачно — стоимость фиксируем в договоре и не
										меняем в процессе
									</p>
								</div>
								<div class="top-about__text">
									<h3>Делаем <span>как для себя!</span></h3>
									<p>
										Для нас важно не просто выполнить задачу,а построить с вами честные и
										доверительные отношения
									</p>
									<p>
										Я лично отвечаю за качество, всегда на связи, внимательно выслушаю ваши
										пожелания и предложу оптимальное решение
									</p>
									<p>
										У нас всё выстроено так, чтобы не тянуть
										резину: все проекты сдаём раньше установленного срока
									</p>
									<p>
										А если всё-таки что-то
										затянется — вы это не оплачиваете, наоборот: мы компенсируем задержку.
									</p>
								</div>
							</div>
						</div>
						<div class="about__bottom bottom-about">
							<div class="bottom-about__left">
								<div class="bottom-about__title">
									Каталог <span>лучших работ с ценой</span>
									и фото каждому <span>подписчику!</span>
								</div>
								<div class="bottom-about__subtitle">
									<img loading="lazy" src="img/icons/bulb.svg" alt="">
									Более 2000 идей для вашего проекта
								</div>
								<p data-da=".bottom-about__right, 767.98">
									Получите автоматически при подписке на канал!
								</p>
								<a data-da=".bottom-about__right, 767.98" href="#"
									class="bottom-about__button button">Перейти в наш TG канал</a>
							</div>
							<div class="bottom-about__center">
								<picture>
									<source srcset="img/book.webp" type="image/webp"><img loading="lazy"
										src="img/book.png" alt="" class="bottom-about__book">
								</picture>
								<picture>
									<source srcset="img/telegram2.webp" type="image/webp"><img loading="lazy"
										src="img/telegram2.png" alt="" class="bottom-about__telegram">
								</picture>
								<div class="bottom-about__block">
									<div class="bottom-about__circle"></div>
									<div class="bottom-about__text">
										<span>Обновлён:</span>
										20 февраля<br> 2024 года
									</div>
								</div>
								<div class="bottom-about__arrow">
									<svg width="277" height="98" viewBox="0 0 277 98" fill="none"
										xmlns="http://www.w3.org/2000/svg">
										<path
											d="M271.572 0.0828097L244.551 21.7593L276.834 34.3218L271.572 0.0828097ZM2 72L0.850624 74.7711C57.2463 98.1625 113.836 102.17 160.944 92.375C207.985 82.5941 245.889 58.9622 264.379 26.7471L261.777 25.2538L259.175 23.7604C241.798 54.036 205.673 76.9465 159.723 86.5006C113.838 96.0409 58.4731 92.1758 3.14938 69.2289L2 72Z"
											fill="white" />
									</svg>
								</div>
							</div>
							<div class="bottom-about__right">
								<picture>
									<source srcset="img/qr-code.webp" type="image/webp"><img loading="lazy"
										src="img/qr-code.png" alt="">
								</picture>
								<span>Или отсканируйте QR код для перехода</span>
							</div>
						</div>
					</div>
				</div>
			</div>
		</main>
		<footer class="footer">
			<div class="footer__container">
				<div class="footer__copy">
					ИП КАЛГАНОВ ВИТАЛИЙ ИВАНОВИЧ
					<br>
					ОГРН 309502736200029
					<br>
					ИНН 502716123378 БИК 502716123378
				</div>
			</div>
		</footer>
	</div>
	<script>
		const modules_flsModules = {};
		let bodyLockStatus = true;
		let bodyUnlock = (delay = 500) => {
			if (bodyLockStatus) {
				const lockPaddingElements = document.querySelectorAll("[data-lp]");
				setTimeout((() => {
					lockPaddingElements.forEach((lockPaddingElement => {
						lockPaddingElement.style.paddingRight = "";
					}));
					document.body.style.paddingRight = "";
					document.documentElement.classList.remove("lock");
				}), delay);
				bodyLockStatus = false;
				setTimeout((function () {
					bodyLockStatus = true;
				}), delay);
			}
		};
		let bodyLock = (delay = 500) => {
			if (bodyLockStatus) {
				const lockPaddingElements = document.querySelectorAll("[data-lp]");
				const lockPaddingValue = window.innerWidth - document.body.offsetWidth + "px";
				lockPaddingElements.forEach((lockPaddingElement => {
					lockPaddingElement.style.paddingRight = lockPaddingValue;
				}));
				document.body.style.paddingRight = lockPaddingValue;
				document.documentElement.classList.add("lock");
				bodyLockStatus = false;
				setTimeout((function () {
					bodyLockStatus = true;
				}), delay);
			}
		};
		function functions_FLS(message) {
			setTimeout((() => {
				if (window.FLS) console.log(message);
			}), 0);
		}
		//Попап
		class Popup {
			constructor(options) {
				let config = {
					logging: true,
					init: true,
					attributeOpenButton: "data-popup",
					attributeCloseButton: "data-close",
					fixElementSelector: "[data-lp]",
					youtubeAttribute: "data-popup-youtube",
					youtubePlaceAttribute: "data-popup-youtube-place",
					setAutoplayYoutube: true,
					classes: {
						popup: "popup",
						popupContent: "popup__content",
						popupActive: "popup_show",
						bodyActive: "popup-show"
					},
					focusCatch: true,
					closeEsc: true,
					bodyLock: true,
					hashSettings: {
						goHash: true
					},
					on: {
						beforeOpen: function () { },
						afterOpen: function () { },
						beforeClose: function () { },
						afterClose: function () { }
					}
				};
				this.youTubeCode;
				this.isOpen = false;
				this.targetOpen = {
					selector: false,
					element: false
				};
				this.previousOpen = {
					selector: false,
					element: false
				};
				this.lastClosed = {
					selector: false,
					element: false
				};
				this._dataValue = false;
				this.hash = false;
				this._reopen = false;
				this._selectorOpen = false;
				this.lastFocusEl = false;
				this._focusEl = ["a[href]", 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', "button:not([disabled]):not([aria-hidden])", "select:not([disabled]):not([aria-hidden])", "textarea:not([disabled]):not([aria-hidden])", "area[href]", "iframe", "object", "embed", "[contenteditable]", '[tabindex]:not([tabindex^="-"])'];
				this.options = {
					...config,
					...options,
					classes: {
						...config.classes,
						...options?.classes
					},
					hashSettings: {
						...config.hashSettings,
						...options?.hashSettings
					},
					on: {
						...config.on,
						...options?.on
					}
				};
				this.bodyLock = false;
				this.options.init ? this.initPopups() : null;
			}
			initPopups() {
				this.popupLogging(`Проснулся`);
				this.eventsPopup();
			}
			eventsPopup() {
				document.addEventListener("click", function (e) {
					const buttonOpen = e.target.closest(`[${this.options.attributeOpenButton}]`);
					if (buttonOpen) {
						e.preventDefault();
						this._dataValue = buttonOpen.getAttribute(this.options.attributeOpenButton) ? buttonOpen.getAttribute(this.options.attributeOpenButton) : "error";
						this.youTubeCode = buttonOpen.getAttribute(this.options.youtubeAttribute) ? buttonOpen.getAttribute(this.options.youtubeAttribute) : null;
						if ("error" !== this._dataValue) {
							if (!this.isOpen) this.lastFocusEl = buttonOpen;
							this.targetOpen.selector = `${this._dataValue}`;
							this._selectorOpen = true;
							this.open();
							return;
						} else this.popupLogging(`Ой ой, не заполнен атрибут у ${buttonOpen.classList}`);
						return;
					}
					const buttonClose = e.target.closest(`[${this.options.attributeCloseButton}]`);
					if (buttonClose || !e.target.closest(`.${this.options.classes.popupContent}`) && this.isOpen) {
						e.preventDefault();
						this.close();
						return;
					}
				}.bind(this));
				document.addEventListener("keydown", function (e) {
					if (this.options.closeEsc && 27 == e.which && "Escape" === e.code && this.isOpen) {
						e.preventDefault();
						this.close();
						return;
					}
					if (this.options.focusCatch && 9 == e.which && this.isOpen) {
						this._focusCatch(e);
						return;
					}
				}.bind(this));
				if (this.options.hashSettings.goHash) {
					window.addEventListener("hashchange", function () {
						if (window.location.hash) this._openToHash(); else this.close(this.targetOpen.selector);
					}.bind(this));
					window.addEventListener("load", function () {
						if (window.location.hash) this._openToHash();
					}.bind(this));
				}
			}
			open(selectorValue) {
				if (bodyLockStatus) {
					this.bodyLock = document.documentElement.classList.contains("lock") && !this.isOpen ? true : false;
					if (selectorValue && "string" === typeof selectorValue && "" !== selectorValue.trim()) {
						this.targetOpen.selector = selectorValue;
						this._selectorOpen = true;
					}
					if (this.isOpen) {
						this._reopen = true;
						this.close();
					}
					if (!this._selectorOpen) this.targetOpen.selector = this.lastClosed.selector;
					if (!this._reopen) this.previousActiveElement = document.activeElement;
					this.targetOpen.element = document.querySelector(this.targetOpen.selector);
					if (this.targetOpen.element) {
						if (this.youTubeCode) {
							const codeVideo = this.youTubeCode;
							const urlVideo = `https://www.youtube.com/embed/${codeVideo}?rel=0&showinfo=0&autoplay=1`;
							const iframe = document.createElement("iframe");
							iframe.setAttribute("allowfullscreen", "");
							const autoplay = this.options.setAutoplayYoutube ? "autoplay;" : "";
							iframe.setAttribute("allow", `${autoplay}; encrypted-media`);
							iframe.setAttribute("src", urlVideo);
							if (!this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`)) {
								this.targetOpen.element.querySelector(".popup__text").setAttribute(`${this.options.youtubePlaceAttribute}`, "");
							}
							this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`).appendChild(iframe);
						}
						const videoElement = this.targetOpen.element.querySelector("video");
						if (videoElement) {
							videoElement.muted = true;
							videoElement.currentTime = 0;
							videoElement.play().catch((e => console.error("Autoplay error:", e)));
						}
						if (this.options.hashSettings.location) {
							this._getHash();
							this._setHash();
						}
						this.options.on.beforeOpen(this);
						document.dispatchEvent(new CustomEvent("beforePopupOpen", {
							detail: {
								popup: this
							}
						}));
						this.targetOpen.element.classList.add(this.options.classes.popupActive);
						document.documentElement.classList.add(this.options.classes.bodyActive);
						if (!this._reopen) !this.bodyLock ? bodyLock() : null; else this._reopen = false;
						this.targetOpen.element.setAttribute("aria-hidden", "false");
						this.previousOpen.selector = this.targetOpen.selector;
						this.previousOpen.element = this.targetOpen.element;
						this._selectorOpen = false;
						this.isOpen = true;
						setTimeout((() => {
							this._focusTrap();
						}), 50);
						this.options.on.afterOpen(this);
						document.dispatchEvent(new CustomEvent("afterPopupOpen", {
							detail: {
								popup: this
							}
						}));
						this.popupLogging(`Открыл попап`);
					} else this.popupLogging(`Ой ой, такого попапа нет.Проверьте корректность ввода. `);
				}
			}
			close(selectorValue) {
				if (selectorValue && "string" === typeof selectorValue && "" !== selectorValue.trim()) this.previousOpen.selector = selectorValue;
				if (!this.isOpen || !bodyLockStatus) return;
				this.options.on.beforeClose(this);
				document.dispatchEvent(new CustomEvent("beforePopupClose", {
					detail: {
						popup: this
					}
				}));
				if (this.youTubeCode) if (this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`)) this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`).innerHTML = "";
				this.previousOpen.element.classList.remove(this.options.classes.popupActive);
				const videoElement = this.previousOpen.element.querySelector("video");
				if (videoElement) videoElement.pause();
				this.previousOpen.element.setAttribute("aria-hidden", "true");
				if (!this._reopen) {
					document.documentElement.classList.remove(this.options.classes.bodyActive);
					!this.bodyLock ? bodyUnlock() : null;
					this.isOpen = false;
				}
				document.dispatchEvent(new CustomEvent("afterPopupClose", {
					detail: {
						popup: this
					}
				}));
				setTimeout((() => {
					this._focusTrap();
				}), 50);
				this.popupLogging(`Закрыл попап`);
			}
			_getHash() {
				if (this.options.hashSettings.location) this.hash = this.targetOpen.selector.includes("#") ? this.targetOpen.selector : this.targetOpen.selector.replace(".", "#");
			}
			_openToHash() {
				let classInHash = document.querySelector(`.${window.location.hash.replace("#", "")}`) ? `.${window.location.hash.replace("#", "")}` : document.querySelector(`${window.location.hash}`) ? `${window.location.hash}` : null;
				const buttons = document.querySelector(`[${this.options.attributeOpenButton} = "${classInHash}"]`) ? document.querySelector(`[${this.options.attributeOpenButton} = "${classInHash}"]`) : document.querySelector(`[${this.options.attributeOpenButton} = "${classInHash.replace(".", "#")}"]`);
				if (buttons && classInHash) this.open(classInHash);
			}
			_setHash() {
				history.pushState("", "", this.hash);
			}
			_removeHash() {
				history.pushState("", "", window.location.href.split("#")[0]);
			}
			_focusCatch(e) {
				const focusable = this.targetOpen.element.querySelectorAll(this._focusEl);
				const focusArray = Array.prototype.slice.call(focusable);
				const focusedIndex = focusArray.indexOf(document.activeElement);
				if (e.shiftKey && 0 === focusedIndex) {
					focusArray[focusArray.length - 1].focus();
					e.preventDefault();
				}
				if (!e.shiftKey && focusedIndex === focusArray.length - 1) {
					focusArray[0].focus();
					e.preventDefault();
				}
			}
			_focusTrap() {
				const focusable = this.previousOpen.element.querySelectorAll(this._focusEl);
				if (!this.isOpen && this.lastFocusEl) this.lastFocusEl.focus(); else focusable[0].focus();
			}
			popupLogging(message) {
				this.options.logging ? functions_FLS(`[Попапос]: ${message}`) : null;
			}
		}
		modules_flsModules.popup = new Popup({});
		//Swiper
		function ssr_window_esm_isObject(obj) {
			return null !== obj && "object" === typeof obj && "constructor" in obj && obj.constructor === Object;
		}
		function extend(target = {}, src = {}) {
			Object.keys(src).forEach((key => {
				if ("undefined" === typeof target[key]) target[key] = src[key]; else if (ssr_window_esm_isObject(src[key]) && ssr_window_esm_isObject(target[key]) && Object.keys(src[key]).length > 0) extend(target[key], src[key]);
			}));
		}
		const ssrDocument = {
			body: {},
			addEventListener() { },
			removeEventListener() { },
			activeElement: {
				blur() { },
				nodeName: ""
			},
			querySelector() {
				return null;
			},
			querySelectorAll() {
				return [];
			},
			getElementById() {
				return null;
			},
			createEvent() {
				return {
					initEvent() { }
				};
			},
			createElement() {
				return {
					children: [],
					childNodes: [],
					style: {},
					setAttribute() { },
					getElementsByTagName() {
						return [];
					}
				};
			},
			createElementNS() {
				return {};
			},
			importNode() {
				return null;
			},
			location: {
				hash: "",
				host: "",
				hostname: "",
				href: "",
				origin: "",
				pathname: "",
				protocol: "",
				search: ""
			}
		};
		function ssr_window_esm_getDocument() {
			const doc = "undefined" !== typeof document ? document : {};
			extend(doc, ssrDocument);
			return doc;
		}
		const ssrWindow = {
			document: ssrDocument,
			navigator: {
				userAgent: ""
			},
			location: {
				hash: "",
				host: "",
				hostname: "",
				href: "",
				origin: "",
				pathname: "",
				protocol: "",
				search: ""
			},
			history: {
				replaceState() { },
				pushState() { },
				go() { },
				back() { }
			},
			CustomEvent: function CustomEvent() {
				return this;
			},
			addEventListener() { },
			removeEventListener() { },
			getComputedStyle() {
				return {
					getPropertyValue() {
						return "";
					}
				};
			},
			Image() { },
			Date() { },
			screen: {},
			setTimeout() { },
			clearTimeout() { },
			matchMedia() {
				return {};
			},
			requestAnimationFrame(callback) {
				if ("undefined" === typeof setTimeout) {
					callback();
					return null;
				}
				return setTimeout(callback, 0);
			},
			cancelAnimationFrame(id) {
				if ("undefined" === typeof setTimeout) return;
				clearTimeout(id);
			}
		};
		function ssr_window_esm_getWindow() {
			const win = "undefined" !== typeof window ? window : {};
			extend(win, ssrWindow);
			return win;
		}
		function makeReactive(obj) {
			const proto = obj.__proto__;
			Object.defineProperty(obj, "__proto__", {
				get() {
					return proto;
				},
				set(value) {
					proto.__proto__ = value;
				}
			});
		}
		class Dom7 extends Array {
			constructor(items) {
				if ("number" === typeof items) super(items); else {
					super(...items || []);
					makeReactive(this);
				}
			}
		}
		function arrayFlat(arr = []) {
			const res = [];
			arr.forEach((el => {
				if (Array.isArray(el)) res.push(...arrayFlat(el)); else res.push(el);
			}));
			return res;
		}
		function arrayFilter(arr, callback) {
			return Array.prototype.filter.call(arr, callback);
		}
		function arrayUnique(arr) {
			const uniqueArray = [];
			for (let i = 0; i < arr.length; i += 1) if (-1 === uniqueArray.indexOf(arr[i])) uniqueArray.push(arr[i]);
			return uniqueArray;
		}
		function qsa(selector, context) {
			if ("string" !== typeof selector) return [selector];
			const a = [];
			const res = context.querySelectorAll(selector);
			for (let i = 0; i < res.length; i += 1) a.push(res[i]);
			return a;
		}
		function dom7_esm_$(selector, context) {
			const window = ssr_window_esm_getWindow();
			const document = ssr_window_esm_getDocument();
			let arr = [];
			if (!context && selector instanceof Dom7) return selector;
			if (!selector) return new Dom7(arr);
			if ("string" === typeof selector) {
				const html = selector.trim();
				if (html.indexOf("<") >= 0 && html.indexOf(">") >= 0) {
					let toCreate = "div";
					if (0 === html.indexOf("<li")) toCreate = "ul";
					if (0 === html.indexOf("<tr")) toCreate = "tbody";
					if (0 === html.indexOf("<td") || 0 === html.indexOf("<th")) toCreate = "tr";
					if (0 === html.indexOf("<tbody")) toCreate = "table";
					if (0 === html.indexOf("<option")) toCreate = "select";
					const tempParent = document.createElement(toCreate);
					tempParent.innerHTML = html;
					for (let i = 0; i < tempParent.childNodes.length; i += 1) arr.push(tempParent.childNodes[i]);
				} else arr = qsa(selector.trim(), context || document);
			} else if (selector.nodeType || selector === window || selector === document) arr.push(selector); else if (Array.isArray(selector)) {
				if (selector instanceof Dom7) return selector;
				arr = selector;
			}
			return new Dom7(arrayUnique(arr));
		}
		dom7_esm_$.fn = Dom7.prototype;
		function addClass(...classes) {
			const classNames = arrayFlat(classes.map((c => c.split(" "))));
			this.forEach((el => {
				el.classList.add(...classNames);
			}));
			return this;
		}
		function removeClass(...classes) {
			const classNames = arrayFlat(classes.map((c => c.split(" "))));
			this.forEach((el => {
				el.classList.remove(...classNames);
			}));
			return this;
		}
		function toggleClass(...classes) {
			const classNames = arrayFlat(classes.map((c => c.split(" "))));
			this.forEach((el => {
				classNames.forEach((className => {
					el.classList.toggle(className);
				}));
			}));
		}
		function hasClass(...classes) {
			const classNames = arrayFlat(classes.map((c => c.split(" "))));
			return arrayFilter(this, (el => classNames.filter((className => el.classList.contains(className))).length > 0)).length > 0;
		}
		function attr(attrs, value) {
			if (1 === arguments.length && "string" === typeof attrs) {
				if (this[0]) return this[0].getAttribute(attrs);
				return;
			}
			for (let i = 0; i < this.length; i += 1) if (2 === arguments.length) this[i].setAttribute(attrs, value); else for (const attrName in attrs) {
				this[i][attrName] = attrs[attrName];
				this[i].setAttribute(attrName, attrs[attrName]);
			}
			return this;
		}
		function removeAttr(attr) {
			for (let i = 0; i < this.length; i += 1) this[i].removeAttribute(attr);
			return this;
		}
		function transform(transform) {
			for (let i = 0; i < this.length; i += 1) this[i].style.transform = transform;
			return this;
		}
		function transition(duration) {
			for (let i = 0; i < this.length; i += 1) this[i].style.transitionDuration = "string" !== typeof duration ? `${duration}ms` : duration;
			return this;
		}
		function on(...args) {
			let [eventType, targetSelector, listener, capture] = args;
			if ("function" === typeof args[1]) {
				[eventType, listener, capture] = args;
				targetSelector = void 0;
			}
			if (!capture) capture = false;
			function handleLiveEvent(e) {
				const target = e.target;
				if (!target) return;
				const eventData = e.target.dom7EventData || [];
				if (eventData.indexOf(e) < 0) eventData.unshift(e);
				if (dom7_esm_$(target).is(targetSelector)) listener.apply(target, eventData); else {
					const parents = dom7_esm_$(target).parents();
					for (let k = 0; k < parents.length; k += 1) if (dom7_esm_$(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
				}
			}
			function handleEvent(e) {
				const eventData = e && e.target ? e.target.dom7EventData || [] : [];
				if (eventData.indexOf(e) < 0) eventData.unshift(e);
				listener.apply(this, eventData);
			}
			const events = eventType.split(" ");
			let j;
			for (let i = 0; i < this.length; i += 1) {
				const el = this[i];
				if (!targetSelector) for (j = 0; j < events.length; j += 1) {
					const event = events[j];
					if (!el.dom7Listeners) el.dom7Listeners = {};
					if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
					el.dom7Listeners[event].push({
						listener,
						proxyListener: handleEvent
					});
					el.addEventListener(event, handleEvent, capture);
				} else for (j = 0; j < events.length; j += 1) {
					const event = events[j];
					if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
					if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
					el.dom7LiveListeners[event].push({
						listener,
						proxyListener: handleLiveEvent
					});
					el.addEventListener(event, handleLiveEvent, capture);
				}
			}
			return this;
		}
		function off(...args) {
			let [eventType, targetSelector, listener, capture] = args;
			if ("function" === typeof args[1]) {
				[eventType, listener, capture] = args;
				targetSelector = void 0;
			}
			if (!capture) capture = false;
			const events = eventType.split(" ");
			for (let i = 0; i < events.length; i += 1) {
				const event = events[i];
				for (let j = 0; j < this.length; j += 1) {
					const el = this[j];
					let handlers;
					if (!targetSelector && el.dom7Listeners) handlers = el.dom7Listeners[event]; else if (targetSelector && el.dom7LiveListeners) handlers = el.dom7LiveListeners[event];
					if (handlers && handlers.length) for (let k = handlers.length - 1; k >= 0; k -= 1) {
						const handler = handlers[k];
						if (listener && handler.listener === listener) {
							el.removeEventListener(event, handler.proxyListener, capture);
							handlers.splice(k, 1);
						} else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
							el.removeEventListener(event, handler.proxyListener, capture);
							handlers.splice(k, 1);
						} else if (!listener) {
							el.removeEventListener(event, handler.proxyListener, capture);
							handlers.splice(k, 1);
						}
					}
				}
			}
			return this;
		}
		function trigger(...args) {
			const window = ssr_window_esm_getWindow();
			const events = args[0].split(" ");
			const eventData = args[1];
			for (let i = 0; i < events.length; i += 1) {
				const event = events[i];
				for (let j = 0; j < this.length; j += 1) {
					const el = this[j];
					if (window.CustomEvent) {
						const evt = new window.CustomEvent(event, {
							detail: eventData,
							bubbles: true,
							cancelable: true
						});
						el.dom7EventData = args.filter(((data, dataIndex) => dataIndex > 0));
						el.dispatchEvent(evt);
						el.dom7EventData = [];
						delete el.dom7EventData;
					}
				}
			}
			return this;
		}
		function transitionEnd(callback) {
			const dom = this;
			function fireCallBack(e) {
				if (e.target !== this) return;
				callback.call(this, e);
				dom.off("transitionend", fireCallBack);
			}
			if (callback) dom.on("transitionend", fireCallBack);
			return this;
		}
		function dom7_esm_outerWidth(includeMargins) {
			if (this.length > 0) {
				if (includeMargins) {
					const styles = this.styles();
					return this[0].offsetWidth + parseFloat(styles.getPropertyValue("margin-right")) + parseFloat(styles.getPropertyValue("margin-left"));
				}
				return this[0].offsetWidth;
			}
			return null;
		}
		function dom7_esm_outerHeight(includeMargins) {
			if (this.length > 0) {
				if (includeMargins) {
					const styles = this.styles();
					return this[0].offsetHeight + parseFloat(styles.getPropertyValue("margin-top")) + parseFloat(styles.getPropertyValue("margin-bottom"));
				}
				return this[0].offsetHeight;
			}
			return null;
		}
		function offset() {
			if (this.length > 0) {
				const window = ssr_window_esm_getWindow();
				const document = ssr_window_esm_getDocument();
				const el = this[0];
				const box = el.getBoundingClientRect();
				const body = document.body;
				const clientTop = el.clientTop || body.clientTop || 0;
				const clientLeft = el.clientLeft || body.clientLeft || 0;
				const scrollTop = el === window ? window.scrollY : el.scrollTop;
				const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
				return {
					top: box.top + scrollTop - clientTop,
					left: box.left + scrollLeft - clientLeft
				};
			}
			return null;
		}
		function styles() {
			const window = ssr_window_esm_getWindow();
			if (this[0]) return window.getComputedStyle(this[0], null);
			return {};
		}
		function css(props, value) {
			const window = ssr_window_esm_getWindow();
			let i;
			if (1 === arguments.length) if ("string" === typeof props) {
				if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
			} else {
				for (i = 0; i < this.length; i += 1) for (const prop in props) this[i].style[prop] = props[prop];
				return this;
			}
			if (2 === arguments.length && "string" === typeof props) {
				for (i = 0; i < this.length; i += 1) this[i].style[props] = value;
				return this;
			}
			return this;
		}
		function each(callback) {
			if (!callback) return this;
			this.forEach(((el, index) => {
				callback.apply(el, [el, index]);
			}));
			return this;
		}
		function filter(callback) {
			const result = arrayFilter(this, callback);
			return dom7_esm_$(result);
		}
		function html(html) {
			if ("undefined" === typeof html) return this[0] ? this[0].innerHTML : null;
			for (let i = 0; i < this.length; i += 1) this[i].innerHTML = html;
			return this;
		}
		function dom7_esm_text(text) {
			if ("undefined" === typeof text) return this[0] ? this[0].textContent.trim() : null;
			for (let i = 0; i < this.length; i += 1) this[i].textContent = text;
			return this;
		}
		function is(selector) {
			const window = ssr_window_esm_getWindow();
			const document = ssr_window_esm_getDocument();
			const el = this[0];
			let compareWith;
			let i;
			if (!el || "undefined" === typeof selector) return false;
			if ("string" === typeof selector) {
				if (el.matches) return el.matches(selector);
				if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
				if (el.msMatchesSelector) return el.msMatchesSelector(selector);
				compareWith = dom7_esm_$(selector);
				for (i = 0; i < compareWith.length; i += 1) if (compareWith[i] === el) return true;
				return false;
			}
			if (selector === document) return el === document;
			if (selector === window) return el === window;
			if (selector.nodeType || selector instanceof Dom7) {
				compareWith = selector.nodeType ? [selector] : selector;
				for (i = 0; i < compareWith.length; i += 1) if (compareWith[i] === el) return true;
				return false;
			}
			return false;
		}
		function index() {
			let child = this[0];
			let i;
			if (child) {
				i = 0;
				while (null !== (child = child.previousSibling)) if (1 === child.nodeType) i += 1;
				return i;
			}
			return;
		}
		function eq(index) {
			if ("undefined" === typeof index) return this;
			const length = this.length;
			if (index > length - 1) return dom7_esm_$([]);
			if (index < 0) {
				const returnIndex = length + index;
				if (returnIndex < 0) return dom7_esm_$([]);
				return dom7_esm_$([this[returnIndex]]);
			}
			return dom7_esm_$([this[index]]);
		}
		function append(...els) {
			let newChild;
			const document = ssr_window_esm_getDocument();
			for (let k = 0; k < els.length; k += 1) {
				newChild = els[k];
				for (let i = 0; i < this.length; i += 1) if ("string" === typeof newChild) {
					const tempDiv = document.createElement("div");
					tempDiv.innerHTML = newChild;
					while (tempDiv.firstChild) this[i].appendChild(tempDiv.firstChild);
				} else if (newChild instanceof Dom7) for (let j = 0; j < newChild.length; j += 1) this[i].appendChild(newChild[j]); else this[i].appendChild(newChild);
			}
			return this;
		}
		function prepend(newChild) {
			const document = ssr_window_esm_getDocument();
			let i;
			let j;
			for (i = 0; i < this.length; i += 1) if ("string" === typeof newChild) {
				const tempDiv = document.createElement("div");
				tempDiv.innerHTML = newChild;
				for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
			} else if (newChild instanceof Dom7) for (j = 0; j < newChild.length; j += 1) this[i].insertBefore(newChild[j], this[i].childNodes[0]); else this[i].insertBefore(newChild, this[i].childNodes[0]);
			return this;
		}
		function next(selector) {
			if (this.length > 0) {
				if (selector) {
					if (this[0].nextElementSibling && dom7_esm_$(this[0].nextElementSibling).is(selector)) return dom7_esm_$([this[0].nextElementSibling]);
					return dom7_esm_$([]);
				}
				if (this[0].nextElementSibling) return dom7_esm_$([this[0].nextElementSibling]);
				return dom7_esm_$([]);
			}
			return dom7_esm_$([]);
		}
		function nextAll(selector) {
			const nextEls = [];
			let el = this[0];
			if (!el) return dom7_esm_$([]);
			while (el.nextElementSibling) {
				const next = el.nextElementSibling;
				if (selector) {
					if (dom7_esm_$(next).is(selector)) nextEls.push(next);
				} else nextEls.push(next);
				el = next;
			}
			return dom7_esm_$(nextEls);
		}
		function prev(selector) {
			if (this.length > 0) {
				const el = this[0];
				if (selector) {
					if (el.previousElementSibling && dom7_esm_$(el.previousElementSibling).is(selector)) return dom7_esm_$([el.previousElementSibling]);
					return dom7_esm_$([]);
				}
				if (el.previousElementSibling) return dom7_esm_$([el.previousElementSibling]);
				return dom7_esm_$([]);
			}
			return dom7_esm_$([]);
		}
		function prevAll(selector) {
			const prevEls = [];
			let el = this[0];
			if (!el) return dom7_esm_$([]);
			while (el.previousElementSibling) {
				const prev = el.previousElementSibling;
				if (selector) {
					if (dom7_esm_$(prev).is(selector)) prevEls.push(prev);
				} else prevEls.push(prev);
				el = prev;
			}
			return dom7_esm_$(prevEls);
		}
		function dom7_esm_parent(selector) {
			const parents = [];
			for (let i = 0; i < this.length; i += 1) if (null !== this[i].parentNode) if (selector) {
				if (dom7_esm_$(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
			} else parents.push(this[i].parentNode);
			return dom7_esm_$(parents);
		}
		function parents(selector) {
			const parents = [];
			for (let i = 0; i < this.length; i += 1) {
				let parent = this[i].parentNode;
				while (parent) {
					if (selector) {
						if (dom7_esm_$(parent).is(selector)) parents.push(parent);
					} else parents.push(parent);
					parent = parent.parentNode;
				}
			}
			return dom7_esm_$(parents);
		}
		function closest(selector) {
			let closest = this;
			if ("undefined" === typeof selector) return dom7_esm_$([]);
			if (!closest.is(selector)) closest = closest.parents(selector).eq(0);
			return closest;
		}
		function find(selector) {
			const foundElements = [];
			for (let i = 0; i < this.length; i += 1) {
				const found = this[i].querySelectorAll(selector);
				for (let j = 0; j < found.length; j += 1) foundElements.push(found[j]);
			}
			return dom7_esm_$(foundElements);
		}
		function children(selector) {
			const children = [];
			for (let i = 0; i < this.length; i += 1) {
				const childNodes = this[i].children;
				for (let j = 0; j < childNodes.length; j += 1) if (!selector || dom7_esm_$(childNodes[j]).is(selector)) children.push(childNodes[j]);
			}
			return dom7_esm_$(children);
		}
		function remove() {
			for (let i = 0; i < this.length; i += 1) if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
			return this;
		}
		const noTrigger = "resize scroll".split(" ");
		function shortcut(name) {
			function eventHandler(...args) {
				if ("undefined" === typeof args[0]) {
					for (let i = 0; i < this.length; i += 1) if (noTrigger.indexOf(name) < 0) if (name in this[i]) this[i][name](); else dom7_esm_$(this[i]).trigger(name);
					return this;
				}
				return this.on(name, ...args);
			}
			return eventHandler;
		}
		shortcut("click");
		shortcut("blur");
		shortcut("focus");
		shortcut("focusin");
		shortcut("focusout");
		shortcut("keyup");
		shortcut("keydown");
		shortcut("keypress");
		shortcut("submit");
		shortcut("change");
		shortcut("mousedown");
		shortcut("mousemove");
		shortcut("mouseup");
		shortcut("mouseenter");
		shortcut("mouseleave");
		shortcut("mouseout");
		shortcut("mouseover");
		shortcut("touchstart");
		shortcut("touchend");
		shortcut("touchmove");
		shortcut("resize");
		shortcut("scroll");
		const Methods = {
			addClass,
			removeClass,
			hasClass,
			toggleClass,
			attr,
			removeAttr,
			transform,
			transition,
			on,
			off,
			trigger,
			transitionEnd,
			outerWidth: dom7_esm_outerWidth,
			outerHeight: dom7_esm_outerHeight,
			styles,
			offset,
			css,
			each,
			html,
			text: dom7_esm_text,
			is,
			index,
			eq,
			append,
			prepend,
			next,
			nextAll,
			prev,
			prevAll,
			parent: dom7_esm_parent,
			parents,
			closest,
			find,
			children,
			filter,
			remove
		};
		Object.keys(Methods).forEach((methodName => {
			Object.defineProperty(dom7_esm_$.fn, methodName, {
				value: Methods[methodName],
				writable: true
			});
		}));
		const dom = dom7_esm_$;
		function deleteProps(obj) {
			const object = obj;
			Object.keys(object).forEach((key => {
				try {
					object[key] = null;
				} catch (e) { }
				try {
					delete object[key];
				} catch (e) { }
			}));
		}
		function utils_nextTick(callback, delay) {
			if (void 0 === delay) delay = 0;
			return setTimeout(callback, delay);
		}
		function utils_now() {
			return Date.now();
		}
		function utils_getComputedStyle(el) {
			const window = ssr_window_esm_getWindow();
			let style;
			if (window.getComputedStyle) style = window.getComputedStyle(el, null);
			if (!style && el.currentStyle) style = el.currentStyle;
			if (!style) style = el.style;
			return style;
		}
		function utils_getTranslate(el, axis) {
			if (void 0 === axis) axis = "x";
			const window = ssr_window_esm_getWindow();
			let matrix;
			let curTransform;
			let transformMatrix;
			const curStyle = utils_getComputedStyle(el, null);
			if (window.WebKitCSSMatrix) {
				curTransform = curStyle.transform || curStyle.webkitTransform;
				if (curTransform.split(",").length > 6) curTransform = curTransform.split(", ").map((a => a.replace(",", "."))).join(", ");
				transformMatrix = new window.WebKitCSSMatrix("none" === curTransform ? "" : curTransform);
			} else {
				transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
				matrix = transformMatrix.toString().split(",");
			}
			if ("x" === axis) if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; else if (16 === matrix.length) curTransform = parseFloat(matrix[12]); else curTransform = parseFloat(matrix[4]);
			if ("y" === axis) if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; else if (16 === matrix.length) curTransform = parseFloat(matrix[13]); else curTransform = parseFloat(matrix[5]);
			return curTransform || 0;
		}
		function utils_isObject(o) {
			return "object" === typeof o && null !== o && o.constructor && "Object" === Object.prototype.toString.call(o).slice(8, -1);
		}
		function isNode(node) {
			if ("undefined" !== typeof window && "undefined" !== typeof window.HTMLElement) return node instanceof HTMLElement;
			return node && (1 === node.nodeType || 11 === node.nodeType);
		}
		function utils_extend() {
			const to = Object(arguments.length <= 0 ? void 0 : arguments[0]);
			const noExtend = ["__proto__", "constructor", "prototype"];
			for (let i = 1; i < arguments.length; i += 1) {
				const nextSource = i < 0 || arguments.length <= i ? void 0 : arguments[i];
				if (void 0 !== nextSource && null !== nextSource && !isNode(nextSource)) {
					const keysArray = Object.keys(Object(nextSource)).filter((key => noExtend.indexOf(key) < 0));
					for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
						const nextKey = keysArray[nextIndex];
						const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
						if (void 0 !== desc && desc.enumerable) if (utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey]; else utils_extend(to[nextKey], nextSource[nextKey]); else if (!utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) {
							to[nextKey] = {};
							if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey]; else utils_extend(to[nextKey], nextSource[nextKey]);
						} else to[nextKey] = nextSource[nextKey];
					}
				}
			}
			return to;
		}
		function utils_setCSSProperty(el, varName, varValue) {
			el.style.setProperty(varName, varValue);
		}
		function animateCSSModeScroll(_ref) {
			let { swiper, targetPosition, side } = _ref;
			const window = ssr_window_esm_getWindow();
			const startPosition = -swiper.translate;
			let startTime = null;
			let time;
			const duration = swiper.params.speed;
			swiper.wrapperEl.style.scrollSnapType = "none";
			window.cancelAnimationFrame(swiper.cssModeFrameID);
			const dir = targetPosition > startPosition ? "next" : "prev";
			const isOutOfBound = (current, target) => "next" === dir && current >= target || "prev" === dir && current <= target;
			const animate = () => {
				time = (new Date).getTime();
				if (null === startTime) startTime = time;
				const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
				const easeProgress = .5 - Math.cos(progress * Math.PI) / 2;
				let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
				if (isOutOfBound(currentPosition, targetPosition)) currentPosition = targetPosition;
				swiper.wrapperEl.scrollTo({
					[side]: currentPosition
				});
				if (isOutOfBound(currentPosition, targetPosition)) {
					swiper.wrapperEl.style.overflow = "hidden";
					swiper.wrapperEl.style.scrollSnapType = "";
					setTimeout((() => {
						swiper.wrapperEl.style.overflow = "";
						swiper.wrapperEl.scrollTo({
							[side]: currentPosition
						});
					}));
					window.cancelAnimationFrame(swiper.cssModeFrameID);
					return;
				}
				swiper.cssModeFrameID = window.requestAnimationFrame(animate);
			};
			animate();
		}
		let support;
		function calcSupport() {
			const window = ssr_window_esm_getWindow();
			const document = ssr_window_esm_getDocument();
			return {
				smoothScroll: document.documentElement && "scrollBehavior" in document.documentElement.style,
				touch: !!("ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch),
				passiveListener: function checkPassiveListener() {
					let supportsPassive = false;
					try {
						const opts = Object.defineProperty({}, "passive", {
							get() {
								supportsPassive = true;
							}
						});
						window.addEventListener("testPassiveListener", null, opts);
					} catch (e) { }
					return supportsPassive;
				}(),
				gestures: function checkGestures() {
					return "ongesturestart" in window;
				}()
			};
		}
		function getSupport() {
			if (!support) support = calcSupport();
			return support;
		}
		let deviceCached;
		function calcDevice(_temp) {
			let { userAgent } = void 0 === _temp ? {} : _temp;
			const support = getSupport();
			const window = ssr_window_esm_getWindow();
			const platform = window.navigator.platform;
			const ua = userAgent || window.navigator.userAgent;
			const device = {
				ios: false,
				android: false
			};
			const screenWidth = window.screen.width;
			const screenHeight = window.screen.height;
			const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
			let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
			const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
			const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
			const windows = "Win32" === platform;
			let macos = "MacIntel" === platform;
			const iPadScreens = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
			if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
				ipad = ua.match(/(Version)\/([\d.]+)/);
				if (!ipad) ipad = [0, 1, "13_0_0"];
				macos = false;
			}
			if (android && !windows) {
				device.os = "android";
				device.android = true;
			}
			if (ipad || iphone || ipod) {
				device.os = "ios";
				device.ios = true;
			}
			return device;
		}
		function getDevice(overrides) {
			if (void 0 === overrides) overrides = {};
			if (!deviceCached) deviceCached = calcDevice(overrides);
			return deviceCached;
		}
		let browser;
		function calcBrowser() {
			const window = ssr_window_esm_getWindow();
			function isSafari() {
				const ua = window.navigator.userAgent.toLowerCase();
				return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
			}
			return {
				isSafari: isSafari(),
				isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
			};
		}
		function getBrowser() {
			if (!browser) browser = calcBrowser();
			return browser;
		}
		function Resize(_ref) {
			let { swiper, on, emit } = _ref;
			const window = ssr_window_esm_getWindow();
			let observer = null;
			let animationFrame = null;
			const resizeHandler = () => {
				if (!swiper || swiper.destroyed || !swiper.initialized) return;
				emit("beforeResize");
				emit("resize");
			};
			const createObserver = () => {
				if (!swiper || swiper.destroyed || !swiper.initialized) return;
				observer = new ResizeObserver((entries => {
					animationFrame = window.requestAnimationFrame((() => {
						const { width, height } = swiper;
						let newWidth = width;
						let newHeight = height;
						entries.forEach((_ref2 => {
							let { contentBoxSize, contentRect, target } = _ref2;
							if (target && target !== swiper.el) return;
							newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
							newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
						}));
						if (newWidth !== width || newHeight !== height) resizeHandler();
					}));
				}));
				observer.observe(swiper.el);
			};
			const removeObserver = () => {
				if (animationFrame) window.cancelAnimationFrame(animationFrame);
				if (observer && observer.unobserve && swiper.el) {
					observer.unobserve(swiper.el);
					observer = null;
				}
			};
			const orientationChangeHandler = () => {
				if (!swiper || swiper.destroyed || !swiper.initialized) return;
				emit("orientationchange");
			};
			on("init", (() => {
				if (swiper.params.resizeObserver && "undefined" !== typeof window.ResizeObserver) {
					createObserver();
					return;
				}
				window.addEventListener("resize", resizeHandler);
				window.addEventListener("orientationchange", orientationChangeHandler);
			}));
			on("destroy", (() => {
				removeObserver();
				window.removeEventListener("resize", resizeHandler);
				window.removeEventListener("orientationchange", orientationChangeHandler);
			}));
		}
		function Observer(_ref) {
			let { swiper, extendParams, on, emit } = _ref;
			const observers = [];
			const window = ssr_window_esm_getWindow();
			const attach = function (target, options) {
				if (void 0 === options) options = {};
				const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
				const observer = new ObserverFunc((mutations => {
					if (1 === mutations.length) {
						emit("observerUpdate", mutations[0]);
						return;
					}
					const observerUpdate = function observerUpdate() {
						emit("observerUpdate", mutations[0]);
					};
					if (window.requestAnimationFrame) window.requestAnimationFrame(observerUpdate); else window.setTimeout(observerUpdate, 0);
				}));
				observer.observe(target, {
					attributes: "undefined" === typeof options.attributes ? true : options.attributes,
					childList: "undefined" === typeof options.childList ? true : options.childList,
					characterData: "undefined" === typeof options.characterData ? true : options.characterData
				});
				observers.push(observer);
			};
			const init = () => {
				if (!swiper.params.observer) return;
				if (swiper.params.observeParents) {
					const containerParents = swiper.$el.parents();
					for (let i = 0; i < containerParents.length; i += 1) attach(containerParents[i]);
				}
				attach(swiper.$el[0], {
					childList: swiper.params.observeSlideChildren
				});
				attach(swiper.$wrapperEl[0], {
					attributes: false
				});
			};
			const destroy = () => {
				observers.forEach((observer => {
					observer.disconnect();
				}));
				observers.splice(0, observers.length);
			};
			extendParams({
				observer: false,
				observeParents: false,
				observeSlideChildren: false
			});
			on("init", init);
			on("destroy", destroy);
		}
		const events_emitter = {
			on(events, handler, priority) {
				const self = this;
				if (!self.eventsListeners || self.destroyed) return self;
				if ("function" !== typeof handler) return self;
				const method = priority ? "unshift" : "push";
				events.split(" ").forEach((event => {
					if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
					self.eventsListeners[event][method](handler);
				}));
				return self;
			},
			once(events, handler, priority) {
				const self = this;
				if (!self.eventsListeners || self.destroyed) return self;
				if ("function" !== typeof handler) return self;
				function onceHandler() {
					self.off(events, onceHandler);
					if (onceHandler.__emitterProxy) delete onceHandler.__emitterProxy;
					for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
					handler.apply(self, args);
				}
				onceHandler.__emitterProxy = handler;
				return self.on(events, onceHandler, priority);
			},
			onAny(handler, priority) {
				const self = this;
				if (!self.eventsListeners || self.destroyed) return self;
				if ("function" !== typeof handler) return self;
				const method = priority ? "unshift" : "push";
				if (self.eventsAnyListeners.indexOf(handler) < 0) self.eventsAnyListeners[method](handler);
				return self;
			},
			offAny(handler) {
				const self = this;
				if (!self.eventsListeners || self.destroyed) return self;
				if (!self.eventsAnyListeners) return self;
				const index = self.eventsAnyListeners.indexOf(handler);
				if (index >= 0) self.eventsAnyListeners.splice(index, 1);
				return self;
			},
			off(events, handler) {
				const self = this;
				if (!self.eventsListeners || self.destroyed) return self;
				if (!self.eventsListeners) return self;
				events.split(" ").forEach((event => {
					if ("undefined" === typeof handler) self.eventsListeners[event] = []; else if (self.eventsListeners[event]) self.eventsListeners[event].forEach(((eventHandler, index) => {
						if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) self.eventsListeners[event].splice(index, 1);
					}));
				}));
				return self;
			},
			emit() {
				const self = this;
				if (!self.eventsListeners || self.destroyed) return self;
				if (!self.eventsListeners) return self;
				let events;
				let data;
				let context;
				for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
				if ("string" === typeof args[0] || Array.isArray(args[0])) {
					events = args[0];
					data = args.slice(1, args.length);
					context = self;
				} else {
					events = args[0].events;
					data = args[0].data;
					context = args[0].context || self;
				}
				data.unshift(context);
				const eventsArray = Array.isArray(events) ? events : events.split(" ");
				eventsArray.forEach((event => {
					if (self.eventsAnyListeners && self.eventsAnyListeners.length) self.eventsAnyListeners.forEach((eventHandler => {
						eventHandler.apply(context, [event, ...data]);
					}));
					if (self.eventsListeners && self.eventsListeners[event]) self.eventsListeners[event].forEach((eventHandler => {
						eventHandler.apply(context, data);
					}));
				}));
				return self;
			}
		};
		function updateSize() {
			const swiper = this;
			let width;
			let height;
			const $el = swiper.$el;
			if ("undefined" !== typeof swiper.params.width && null !== swiper.params.width) width = swiper.params.width; else width = $el[0].clientWidth;
			if ("undefined" !== typeof swiper.params.height && null !== swiper.params.height) height = swiper.params.height; else height = $el[0].clientHeight;
			if (0 === width && swiper.isHorizontal() || 0 === height && swiper.isVertical()) return;
			width = width - parseInt($el.css("padding-left") || 0, 10) - parseInt($el.css("padding-right") || 0, 10);
			height = height - parseInt($el.css("padding-top") || 0, 10) - parseInt($el.css("padding-bottom") || 0, 10);
			if (Number.isNaN(width)) width = 0;
			if (Number.isNaN(height)) height = 0;
			Object.assign(swiper, {
				width,
				height,
				size: swiper.isHorizontal() ? width : height
			});
		}
		function updateSlides() {
			const swiper = this;
			function getDirectionLabel(property) {
				if (swiper.isHorizontal()) return property;
				return {
					width: "height",
					"margin-top": "margin-left",
					"margin-bottom ": "margin-right",
					"margin-left": "margin-top",
					"margin-right": "margin-bottom",
					"padding-left": "padding-top",
					"padding-right": "padding-bottom",
					marginRight: "marginBottom"
				}[property];
			}
			function getDirectionPropertyValue(node, label) {
				return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
			}
			const params = swiper.params;
			const { $wrapperEl, size: swiperSize, rtlTranslate: rtl, wrongRTL } = swiper;
			const isVirtual = swiper.virtual && params.virtual.enabled;
			const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
			const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
			const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
			let snapGrid = [];
			const slidesGrid = [];
			const slidesSizesGrid = [];
			let offsetBefore = params.slidesOffsetBefore;
			if ("function" === typeof offsetBefore) offsetBefore = params.slidesOffsetBefore.call(swiper);
			let offsetAfter = params.slidesOffsetAfter;
			if ("function" === typeof offsetAfter) offsetAfter = params.slidesOffsetAfter.call(swiper);
			const previousSnapGridLength = swiper.snapGrid.length;
			const previousSlidesGridLength = swiper.slidesGrid.length;
			let spaceBetween = params.spaceBetween;
			let slidePosition = -offsetBefore;
			let prevSlideSize = 0;
			let index = 0;
			if ("undefined" === typeof swiperSize) return;
			if ("string" === typeof spaceBetween && spaceBetween.indexOf("%") >= 0) spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize;
			swiper.virtualSize = -spaceBetween;
			if (rtl) slides.css({
				marginLeft: "",
				marginBottom: "",
				marginTop: ""
			}); else slides.css({
				marginRight: "",
				marginBottom: "",
				marginTop: ""
			});
			if (params.centeredSlides && params.cssMode) {
				utils_setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-before", "");
				utils_setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-after", "");
			}
			const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
			if (gridEnabled) swiper.grid.initSlides(slidesLength);
			let slideSize;
			const shouldResetSlideSize = "auto" === params.slidesPerView && params.breakpoints && Object.keys(params.breakpoints).filter((key => "undefined" !== typeof params.breakpoints[key].slidesPerView)).length > 0;
			for (let i = 0; i < slidesLength; i += 1) {
				slideSize = 0;
				const slide = slides.eq(i);
				if (gridEnabled) swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);
				if ("none" === slide.css("display")) continue;
				if ("auto" === params.slidesPerView) {
					if (shouldResetSlideSize) slides[i].style[getDirectionLabel("width")] = ``;
					const slideStyles = getComputedStyle(slide[0]);
					const currentTransform = slide[0].style.transform;
					const currentWebKitTransform = slide[0].style.webkitTransform;
					if (currentTransform) slide[0].style.transform = "none";
					if (currentWebKitTransform) slide[0].style.webkitTransform = "none";
					if (params.roundLengths) slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true); else {
						const width = getDirectionPropertyValue(slideStyles, "width");
						const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
						const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
						const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
						const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
						const boxSizing = slideStyles.getPropertyValue("box-sizing");
						if (boxSizing && "border-box" === boxSizing) slideSize = width + marginLeft + marginRight; else {
							const { clientWidth, offsetWidth } = slide[0];
							slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
						}
					}
					if (currentTransform) slide[0].style.transform = currentTransform;
					if (currentWebKitTransform) slide[0].style.webkitTransform = currentWebKitTransform;
					if (params.roundLengths) slideSize = Math.floor(slideSize);
				} else {
					slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
					if (params.roundLengths) slideSize = Math.floor(slideSize);
					if (slides[i]) slides[i].style[getDirectionLabel("width")] = `${slideSize}px`;
				}
				if (slides[i]) slides[i].swiperSlideSize = slideSize;
				slidesSizesGrid.push(slideSize);
				if (params.centeredSlides) {
					slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
					if (0 === prevSlideSize && 0 !== i) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
					if (0 === i) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
					if (Math.abs(slidePosition) < 1 / 1e3) slidePosition = 0;
					if (params.roundLengths) slidePosition = Math.floor(slidePosition);
					if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
					slidesGrid.push(slidePosition);
				} else {
					if (params.roundLengths) slidePosition = Math.floor(slidePosition);
					if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
					slidesGrid.push(slidePosition);
					slidePosition = slidePosition + slideSize + spaceBetween;
				}
				swiper.virtualSize += slideSize + spaceBetween;
				prevSlideSize = slideSize;
				index += 1;
			}
			swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
			if (rtl && wrongRTL && ("slide" === params.effect || "coverflow" === params.effect)) $wrapperEl.css({
				width: `${swiper.virtualSize + params.spaceBetween}px`
			});
			if (params.setWrapperSize) $wrapperEl.css({
				[getDirectionLabel("width")]: `${swiper.virtualSize + params.spaceBetween}px`
			});
			if (gridEnabled) swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
			if (!params.centeredSlides) {
				const newSlidesGrid = [];
				for (let i = 0; i < snapGrid.length; i += 1) {
					let slidesGridItem = snapGrid[i];
					if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
					if (snapGrid[i] <= swiper.virtualSize - swiperSize) newSlidesGrid.push(slidesGridItem);
				}
				snapGrid = newSlidesGrid;
				if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) snapGrid.push(swiper.virtualSize - swiperSize);
			}
			if (0 === snapGrid.length) snapGrid = [0];
			if (0 !== params.spaceBetween) {
				const key = swiper.isHorizontal() && rtl ? "marginLeft" : getDirectionLabel("marginRight");
				slides.filter(((_, slideIndex) => {
					if (!params.cssMode) return true;
					if (slideIndex === slides.length - 1) return false;
					return true;
				})).css({
					[key]: `${spaceBetween}px`
				});
			}
			if (params.centeredSlides && params.centeredSlidesBounds) {
				let allSlidesSize = 0;
				slidesSizesGrid.forEach((slideSizeValue => {
					allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
				}));
				allSlidesSize -= params.spaceBetween;
				const maxSnap = allSlidesSize - swiperSize;
				snapGrid = snapGrid.map((snap => {
					if (snap < 0) return -offsetBefore;
					if (snap > maxSnap) return maxSnap + offsetAfter;
					return snap;
				}));
			}
			if (params.centerInsufficientSlides) {
				let allSlidesSize = 0;
				slidesSizesGrid.forEach((slideSizeValue => {
					allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
				}));
				allSlidesSize -= params.spaceBetween;
				if (allSlidesSize < swiperSize) {
					const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
					snapGrid.forEach(((snap, snapIndex) => {
						snapGrid[snapIndex] = snap - allSlidesOffset;
					}));
					slidesGrid.forEach(((snap, snapIndex) => {
						slidesGrid[snapIndex] = snap + allSlidesOffset;
					}));
				}
			}
			Object.assign(swiper, {
				slides,
				snapGrid,
				slidesGrid,
				slidesSizesGrid
			});
			if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
				utils_setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
				utils_setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-after", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
				const addToSnapGrid = -swiper.snapGrid[0];
				const addToSlidesGrid = -swiper.slidesGrid[0];
				swiper.snapGrid = swiper.snapGrid.map((v => v + addToSnapGrid));
				swiper.slidesGrid = swiper.slidesGrid.map((v => v + addToSlidesGrid));
			}
			if (slidesLength !== previousSlidesLength) swiper.emit("slidesLengthChange");
			if (snapGrid.length !== previousSnapGridLength) {
				if (swiper.params.watchOverflow) swiper.checkOverflow();
				swiper.emit("snapGridLengthChange");
			}
			if (slidesGrid.length !== previousSlidesGridLength) swiper.emit("slidesGridLengthChange");
			if (params.watchSlidesProgress) swiper.updateSlidesOffset();
			if (!isVirtual && !params.cssMode && ("slide" === params.effect || "fade" === params.effect)) {
				const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
				const hasClassBackfaceClassAdded = swiper.$el.hasClass(backFaceHiddenClass);
				if (slidesLength <= params.maxBackfaceHiddenSlides) {
					if (!hasClassBackfaceClassAdded) swiper.$el.addClass(backFaceHiddenClass);
				} else if (hasClassBackfaceClassAdded) swiper.$el.removeClass(backFaceHiddenClass);
			}
		}
		function updateAutoHeight(speed) {
			const swiper = this;
			const activeSlides = [];
			const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
			let newHeight = 0;
			let i;
			if ("number" === typeof speed) swiper.setTransition(speed); else if (true === speed) swiper.setTransition(swiper.params.speed);
			const getSlideByIndex = index => {
				if (isVirtual) return swiper.slides.filter((el => parseInt(el.getAttribute("data-swiper-slide-index"), 10) === index))[0];
				return swiper.slides.eq(index)[0];
			};
			if ("auto" !== swiper.params.slidesPerView && swiper.params.slidesPerView > 1) if (swiper.params.centeredSlides) (swiper.visibleSlides || dom([])).each((slide => {
				activeSlides.push(slide);
			})); else for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
				const index = swiper.activeIndex + i;
				if (index > swiper.slides.length && !isVirtual) break;
				activeSlides.push(getSlideByIndex(index));
			} else activeSlides.push(getSlideByIndex(swiper.activeIndex));
			for (i = 0; i < activeSlides.length; i += 1) if ("undefined" !== typeof activeSlides[i]) {
				const height = activeSlides[i].offsetHeight;
				newHeight = height > newHeight ? height : newHeight;
			}
			if (newHeight || 0 === newHeight) swiper.$wrapperEl.css("height", `${newHeight}px`);
		}
		function updateSlidesOffset() {
			const swiper = this;
			const slides = swiper.slides;
			for (let i = 0; i < slides.length; i += 1) slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
		}
		function updateSlidesProgress(translate) {
			if (void 0 === translate) translate = this && this.translate || 0;
			const swiper = this;
			const params = swiper.params;
			const { slides, rtlTranslate: rtl, snapGrid } = swiper;
			if (0 === slides.length) return;
			if ("undefined" === typeof slides[0].swiperSlideOffset) swiper.updateSlidesOffset();
			let offsetCenter = -translate;
			if (rtl) offsetCenter = translate;
			slides.removeClass(params.slideVisibleClass);
			swiper.visibleSlidesIndexes = [];
			swiper.visibleSlides = [];
			for (let i = 0; i < slides.length; i += 1) {
				const slide = slides[i];
				let slideOffset = slide.swiperSlideOffset;
				if (params.cssMode && params.centeredSlides) slideOffset -= slides[0].swiperSlideOffset;
				const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
				const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
				const slideBefore = -(offsetCenter - slideOffset);
				const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
				const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
				if (isVisible) {
					swiper.visibleSlides.push(slide);
					swiper.visibleSlidesIndexes.push(i);
					slides.eq(i).addClass(params.slideVisibleClass);
				}
				slide.progress = rtl ? -slideProgress : slideProgress;
				slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
			}
			swiper.visibleSlides = dom(swiper.visibleSlides);
		}
		function updateProgress(translate) {
			const swiper = this;
			if ("undefined" === typeof translate) {
				const multiplier = swiper.rtlTranslate ? -1 : 1;
				translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
			}
			const params = swiper.params;
			const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
			let { progress, isBeginning, isEnd } = swiper;
			const wasBeginning = isBeginning;
			const wasEnd = isEnd;
			if (0 === translatesDiff) {
				progress = 0;
				isBeginning = true;
				isEnd = true;
			} else {
				progress = (translate - swiper.minTranslate()) / translatesDiff;
				isBeginning = progress <= 0;
				isEnd = progress >= 1;
			}
			Object.assign(swiper, {
				progress,
				isBeginning,
				isEnd
			});
			if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
			if (isBeginning && !wasBeginning) swiper.emit("reachBeginning toEdge");
			if (isEnd && !wasEnd) swiper.emit("reachEnd toEdge");
			if (wasBeginning && !isBeginning || wasEnd && !isEnd) swiper.emit("fromEdge");
			swiper.emit("progress", progress);
		}
		function updateSlidesClasses() {
			const swiper = this;
			const { slides, params, $wrapperEl, activeIndex, realIndex } = swiper;
			const isVirtual = swiper.virtual && params.virtual.enabled;
			slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);
			let activeSlide;
			if (isVirtual) activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`); else activeSlide = slides.eq(activeIndex);
			activeSlide.addClass(params.slideActiveClass);
			if (params.loop) if (activeSlide.hasClass(params.slideDuplicateClass)) $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass); else $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
			let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);
			if (params.loop && 0 === nextSlide.length) {
				nextSlide = slides.eq(0);
				nextSlide.addClass(params.slideNextClass);
			}
			let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);
			if (params.loop && 0 === prevSlide.length) {
				prevSlide = slides.eq(-1);
				prevSlide.addClass(params.slidePrevClass);
			}
			if (params.loop) {
				if (nextSlide.hasClass(params.slideDuplicateClass)) $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicateNextClass); else $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicateNextClass);
				if (prevSlide.hasClass(params.slideDuplicateClass)) $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicatePrevClass); else $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicatePrevClass);
			}
			swiper.emitSlidesClasses();
		}
		function updateActiveIndex(newActiveIndex) {
			const swiper = this;
			const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
			const { slidesGrid, snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex } = swiper;
			let activeIndex = newActiveIndex;
			let snapIndex;
			if ("undefined" === typeof activeIndex) {
				for (let i = 0; i < slidesGrid.length; i += 1) if ("undefined" !== typeof slidesGrid[i + 1]) {
					if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) activeIndex = i; else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) activeIndex = i + 1;
				} else if (translate >= slidesGrid[i]) activeIndex = i;
				if (params.normalizeSlideIndex) if (activeIndex < 0 || "undefined" === typeof activeIndex) activeIndex = 0;
			}
			if (snapGrid.indexOf(translate) >= 0) snapIndex = snapGrid.indexOf(translate); else {
				const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
				snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
			}
			if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
			if (activeIndex === previousIndex) {
				if (snapIndex !== previousSnapIndex) {
					swiper.snapIndex = snapIndex;
					swiper.emit("snapIndexChange");
				}
				return;
			}
			const realIndex = parseInt(swiper.slides.eq(activeIndex).attr("data-swiper-slide-index") || activeIndex, 10);
			Object.assign(swiper, {
				snapIndex,
				realIndex,
				previousIndex,
				activeIndex
			});
			swiper.emit("activeIndexChange");
			swiper.emit("snapIndexChange");
			if (previousRealIndex !== realIndex) swiper.emit("realIndexChange");
			if (swiper.initialized || swiper.params.runCallbacksOnInit) swiper.emit("slideChange");
		}
		function updateClickedSlide(e) {
			const swiper = this;
			const params = swiper.params;
			const slide = dom(e).closest(`.${params.slideClass}`)[0];
			let slideFound = false;
			let slideIndex;
			if (slide) for (let i = 0; i < swiper.slides.length; i += 1) if (swiper.slides[i] === slide) {
				slideFound = true;
				slideIndex = i;
				break;
			}
			if (slide && slideFound) {
				swiper.clickedSlide = slide;
				if (swiper.virtual && swiper.params.virtual.enabled) swiper.clickedIndex = parseInt(dom(slide).attr("data-swiper-slide-index"), 10); else swiper.clickedIndex = slideIndex;
			} else {
				swiper.clickedSlide = void 0;
				swiper.clickedIndex = void 0;
				return;
			}
			if (params.slideToClickedSlide && void 0 !== swiper.clickedIndex && swiper.clickedIndex !== swiper.activeIndex) swiper.slideToClickedSlide();
		}
		const update = {
			updateSize,
			updateSlides,
			updateAutoHeight,
			updateSlidesOffset,
			updateSlidesProgress,
			updateProgress,
			updateSlidesClasses,
			updateActiveIndex,
			updateClickedSlide
		};
		function getSwiperTranslate(axis) {
			if (void 0 === axis) axis = this.isHorizontal() ? "x" : "y";
			const swiper = this;
			const { params, rtlTranslate: rtl, translate, $wrapperEl } = swiper;
			if (params.virtualTranslate) return rtl ? -translate : translate;
			if (params.cssMode) return translate;
			let currentTranslate = utils_getTranslate($wrapperEl[0], axis);
			if (rtl) currentTranslate = -currentTranslate;
			return currentTranslate || 0;
		}
		function setTranslate(translate, byController) {
			const swiper = this;
			const { rtlTranslate: rtl, params, $wrapperEl, wrapperEl, progress } = swiper;
			let x = 0;
			let y = 0;
			const z = 0;
			if (swiper.isHorizontal()) x = rtl ? -translate : translate; else y = translate;
			if (params.roundLengths) {
				x = Math.floor(x);
				y = Math.floor(y);
			}
			if (params.cssMode) wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x : -y; else if (!params.virtualTranslate) $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
			swiper.previousTranslate = swiper.translate;
			swiper.translate = swiper.isHorizontal() ? x : y;
			let newProgress;
			const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
			if (0 === translatesDiff) newProgress = 0; else newProgress = (translate - swiper.minTranslate()) / translatesDiff;
			if (newProgress !== progress) swiper.updateProgress(translate);
			swiper.emit("setTranslate", swiper.translate, byController);
		}
		function minTranslate() {
			return -this.snapGrid[0];
		}
		function maxTranslate() {
			return -this.snapGrid[this.snapGrid.length - 1];
		}
		function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
			if (void 0 === translate) translate = 0;
			if (void 0 === speed) speed = this.params.speed;
			if (void 0 === runCallbacks) runCallbacks = true;
			if (void 0 === translateBounds) translateBounds = true;
			const swiper = this;
			const { params, wrapperEl } = swiper;
			if (swiper.animating && params.preventInteractionOnTransition) return false;
			const minTranslate = swiper.minTranslate();
			const maxTranslate = swiper.maxTranslate();
			let newTranslate;
			if (translateBounds && translate > minTranslate) newTranslate = minTranslate; else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate; else newTranslate = translate;
			swiper.updateProgress(newTranslate);
			if (params.cssMode) {
				const isH = swiper.isHorizontal();
				if (0 === speed) wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate; else {
					if (!swiper.support.smoothScroll) {
						animateCSSModeScroll({
							swiper,
							targetPosition: -newTranslate,
							side: isH ? "left" : "top"
						});
						return true;
					}
					wrapperEl.scrollTo({
						[isH ? "left" : "top"]: -newTranslate,
						behavior: "smooth"
					});
				}
				return true;
			}
			if (0 === speed) {
				swiper.setTransition(0);
				swiper.setTranslate(newTranslate);
				if (runCallbacks) {
					swiper.emit("beforeTransitionStart", speed, internal);
					swiper.emit("transitionEnd");
				}
			} else {
				swiper.setTransition(speed);
				swiper.setTranslate(newTranslate);
				if (runCallbacks) {
					swiper.emit("beforeTransitionStart", speed, internal);
					swiper.emit("transitionStart");
				}
				if (!swiper.animating) {
					swiper.animating = true;
					if (!swiper.onTranslateToWrapperTransitionEnd) swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
						if (!swiper || swiper.destroyed) return;
						if (e.target !== this) return;
						swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
						swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.onTranslateToWrapperTransitionEnd);
						swiper.onTranslateToWrapperTransitionEnd = null;
						delete swiper.onTranslateToWrapperTransitionEnd;
						if (runCallbacks) swiper.emit("transitionEnd");
					};
					swiper.$wrapperEl[0].addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
					swiper.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper.onTranslateToWrapperTransitionEnd);
				}
			}
			return true;
		}
		const translate = {
			getTranslate: getSwiperTranslate,
			setTranslate,
			minTranslate,
			maxTranslate,
			translateTo
		};
		function setTransition(duration, byController) {
			const swiper = this;
			if (!swiper.params.cssMode) swiper.$wrapperEl.transition(duration);
			swiper.emit("setTransition", duration, byController);
		}
		function transitionEmit(_ref) {
			let { swiper, runCallbacks, direction, step } = _ref;
			const { activeIndex, previousIndex } = swiper;
			let dir = direction;
			if (!dir) if (activeIndex > previousIndex) dir = "next"; else if (activeIndex < previousIndex) dir = "prev"; else dir = "reset";
			swiper.emit(`transition${step}`);
			if (runCallbacks && activeIndex !== previousIndex) {
				if ("reset" === dir) {
					swiper.emit(`slideResetTransition${step}`);
					return;
				}
				swiper.emit(`slideChangeTransition${step}`);
				if ("next" === dir) swiper.emit(`slideNextTransition${step}`); else swiper.emit(`slidePrevTransition${step}`);
			}
		}
		function transitionStart(runCallbacks, direction) {
			if (void 0 === runCallbacks) runCallbacks = true;
			const swiper = this;
			const { params } = swiper;
			if (params.cssMode) return;
			if (params.autoHeight) swiper.updateAutoHeight();
			transitionEmit({
				swiper,
				runCallbacks,
				direction,
				step: "Start"
			});
		}
		function transitionEnd_transitionEnd(runCallbacks, direction) {
			if (void 0 === runCallbacks) runCallbacks = true;
			const swiper = this;
			const { params } = swiper;
			swiper.animating = false;
			if (params.cssMode) return;
			swiper.setTransition(0);
			transitionEmit({
				swiper,
				runCallbacks,
				direction,
				step: "End"
			});
		}
		const core_transition = {
			setTransition,
			transitionStart,
			transitionEnd: transitionEnd_transitionEnd
		};
		function slideTo(index, speed, runCallbacks, internal, initial) {
			if (void 0 === index) index = 0;
			if (void 0 === speed) speed = this.params.speed;
			if (void 0 === runCallbacks) runCallbacks = true;
			if ("number" !== typeof index && "string" !== typeof index) throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index}] given.`);
			if ("string" === typeof index) {
				const indexAsNumber = parseInt(index, 10);
				const isValidNumber = isFinite(indexAsNumber);
				if (!isValidNumber) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);
				index = indexAsNumber;
			}
			const swiper = this;
			let slideIndex = index;
			if (slideIndex < 0) slideIndex = 0;
			const { params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl, wrapperEl, enabled } = swiper;
			if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) return false;
			const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
			let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
			if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
			if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) swiper.emit("beforeSlideChangeStart");
			const translate = -snapGrid[snapIndex];
			swiper.updateProgress(translate);
			if (params.normalizeSlideIndex) for (let i = 0; i < slidesGrid.length; i += 1) {
				const normalizedTranslate = -Math.floor(100 * translate);
				const normalizedGrid = Math.floor(100 * slidesGrid[i]);
				const normalizedGridNext = Math.floor(100 * slidesGrid[i + 1]);
				if ("undefined" !== typeof slidesGrid[i + 1]) {
					if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) slideIndex = i; else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) slideIndex = i + 1;
				} else if (normalizedTranslate >= normalizedGrid) slideIndex = i;
			}
			if (swiper.initialized && slideIndex !== activeIndex) {
				if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) return false;
				if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) if ((activeIndex || 0) !== slideIndex) return false;
			}
			let direction;
			if (slideIndex > activeIndex) direction = "next"; else if (slideIndex < activeIndex) direction = "prev"; else direction = "reset";
			if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
				swiper.updateActiveIndex(slideIndex);
				if (params.autoHeight) swiper.updateAutoHeight();
				swiper.updateSlidesClasses();
				if ("slide" !== params.effect) swiper.setTranslate(translate);
				if ("reset" !== direction) {
					swiper.transitionStart(runCallbacks, direction);
					swiper.transitionEnd(runCallbacks, direction);
				}
				return false;
			}
			if (params.cssMode) {
				const isH = swiper.isHorizontal();
				const t = rtl ? translate : -translate;
				if (0 === speed) {
					const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
					if (isVirtual) {
						swiper.wrapperEl.style.scrollSnapType = "none";
						swiper._immediateVirtual = true;
					}
					wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
					if (isVirtual) requestAnimationFrame((() => {
						swiper.wrapperEl.style.scrollSnapType = "";
						swiper._swiperImmediateVirtual = false;
					}));
				} else {
					if (!swiper.support.smoothScroll) {
						animateCSSModeScroll({
							swiper,
							targetPosition: t,
							side: isH ? "left" : "top"
						});
						return true;
					}
					wrapperEl.scrollTo({
						[isH ? "left" : "top"]: t,
						behavior: "smooth"
					});
				}
				return true;
			}
			swiper.setTransition(speed);
			swiper.setTranslate(translate);
			swiper.updateActiveIndex(slideIndex);
			swiper.updateSlidesClasses();
			swiper.emit("beforeTransitionStart", speed, internal);
			swiper.transitionStart(runCallbacks, direction);
			if (0 === speed) swiper.transitionEnd(runCallbacks, direction); else if (!swiper.animating) {
				swiper.animating = true;
				if (!swiper.onSlideToWrapperTransitionEnd) swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
					if (!swiper || swiper.destroyed) return;
					if (e.target !== this) return;
					swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
					swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd);
					swiper.onSlideToWrapperTransitionEnd = null;
					delete swiper.onSlideToWrapperTransitionEnd;
					swiper.transitionEnd(runCallbacks, direction);
				};
				swiper.$wrapperEl[0].addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
				swiper.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd);
			}
			return true;
		}
		function slideToLoop(index, speed, runCallbacks, internal) {
			if (void 0 === index) index = 0;
			if (void 0 === speed) speed = this.params.speed;
			if (void 0 === runCallbacks) runCallbacks = true;
			if ("string" === typeof index) {
				const indexAsNumber = parseInt(index, 10);
				const isValidNumber = isFinite(indexAsNumber);
				if (!isValidNumber) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);
				index = indexAsNumber;
			}
			const swiper = this;
			let newIndex = index;
			if (swiper.params.loop) newIndex += swiper.loopedSlides;
			return swiper.slideTo(newIndex, speed, runCallbacks, internal);
		}
		function slideNext(speed, runCallbacks, internal) {
			if (void 0 === speed) speed = this.params.speed;
			if (void 0 === runCallbacks) runCallbacks = true;
			const swiper = this;
			const { animating, enabled, params } = swiper;
			if (!enabled) return swiper;
			let perGroup = params.slidesPerGroup;
			if ("auto" === params.slidesPerView && 1 === params.slidesPerGroup && params.slidesPerGroupAuto) perGroup = Math.max(swiper.slidesPerViewDynamic("current", true), 1);
			const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
			if (params.loop) {
				if (animating && params.loopPreventsSlide) return false;
				swiper.loopFix();
				swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
			}
			if (params.rewind && swiper.isEnd) return swiper.slideTo(0, speed, runCallbacks, internal);
			return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
		}
		function slidePrev(speed, runCallbacks, internal) {
			if (void 0 === speed) speed = this.params.speed;
			if (void 0 === runCallbacks) runCallbacks = true;
			const swiper = this;
			const { params, animating, snapGrid, slidesGrid, rtlTranslate, enabled } = swiper;
			if (!enabled) return swiper;
			if (params.loop) {
				if (animating && params.loopPreventsSlide) return false;
				swiper.loopFix();
				swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
			}
			const translate = rtlTranslate ? swiper.translate : -swiper.translate;
			function normalize(val) {
				if (val < 0) return -Math.floor(Math.abs(val));
				return Math.floor(val);
			}
			const normalizedTranslate = normalize(translate);
			const normalizedSnapGrid = snapGrid.map((val => normalize(val)));
			let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
			if ("undefined" === typeof prevSnap && params.cssMode) {
				let prevSnapIndex;
				snapGrid.forEach(((snap, snapIndex) => {
					if (normalizedTranslate >= snap) prevSnapIndex = snapIndex;
				}));
				if ("undefined" !== typeof prevSnapIndex) prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
			}
			let prevIndex = 0;
			if ("undefined" !== typeof prevSnap) {
				prevIndex = slidesGrid.indexOf(prevSnap);
				if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
				if ("auto" === params.slidesPerView && 1 === params.slidesPerGroup && params.slidesPerGroupAuto) {
					prevIndex = prevIndex - swiper.slidesPerViewDynamic("previous", true) + 1;
					prevIndex = Math.max(prevIndex, 0);
				}
			}
			if (params.rewind && swiper.isBeginning) {
				const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
				return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
			}
			return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
		}
		function slideReset(speed, runCallbacks, internal) {
			if (void 0 === speed) speed = this.params.speed;
			if (void 0 === runCallbacks) runCallbacks = true;
			const swiper = this;
			return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
		}
		function slideToClosest(speed, runCallbacks, internal, threshold) {
			if (void 0 === speed) speed = this.params.speed;
			if (void 0 === runCallbacks) runCallbacks = true;
			if (void 0 === threshold) threshold = .5;
			const swiper = this;
			let index = swiper.activeIndex;
			const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
			const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
			const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
			if (translate >= swiper.snapGrid[snapIndex]) {
				const currentSnap = swiper.snapGrid[snapIndex];
				const nextSnap = swiper.snapGrid[snapIndex + 1];
				if (translate - currentSnap > (nextSnap - currentSnap) * threshold) index += swiper.params.slidesPerGroup;
			} else {
				const prevSnap = swiper.snapGrid[snapIndex - 1];
				const currentSnap = swiper.snapGrid[snapIndex];
				if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) index -= swiper.params.slidesPerGroup;
			}
			index = Math.max(index, 0);
			index = Math.min(index, swiper.slidesGrid.length - 1);
			return swiper.slideTo(index, speed, runCallbacks, internal);
		}
		function slideToClickedSlide() {
			const swiper = this;
			const { params, $wrapperEl } = swiper;
			const slidesPerView = "auto" === params.slidesPerView ? swiper.slidesPerViewDynamic() : params.slidesPerView;
			let slideToIndex = swiper.clickedIndex;
			let realIndex;
			if (params.loop) {
				if (swiper.animating) return;
				realIndex = parseInt(dom(swiper.clickedSlide).attr("data-swiper-slide-index"), 10);
				if (params.centeredSlides) if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
					swiper.loopFix();
					slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
					utils_nextTick((() => {
						swiper.slideTo(slideToIndex);
					}));
				} else swiper.slideTo(slideToIndex); else if (slideToIndex > swiper.slides.length - slidesPerView) {
					swiper.loopFix();
					slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
					utils_nextTick((() => {
						swiper.slideTo(slideToIndex);
					}));
				} else swiper.slideTo(slideToIndex);
			} else swiper.slideTo(slideToIndex);
		}
		const slide = {
			slideTo,
			slideToLoop,
			slideNext,
			slidePrev,
			slideReset,
			slideToClosest,
			slideToClickedSlide
		};
		function loopCreate() {
			const swiper = this;
			const document = ssr_window_esm_getDocument();
			const { params, $wrapperEl } = swiper;
			const $selector = $wrapperEl.children().length > 0 ? dom($wrapperEl.children()[0].parentNode) : $wrapperEl;
			$selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
			let slides = $selector.children(`.${params.slideClass}`);
			if (params.loopFillGroupWithBlank) {
				const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;
				if (blankSlidesNum !== params.slidesPerGroup) {
					for (let i = 0; i < blankSlidesNum; i += 1) {
						const blankNode = dom(document.createElement("div")).addClass(`${params.slideClass} ${params.slideBlankClass}`);
						$selector.append(blankNode);
					}
					slides = $selector.children(`.${params.slideClass}`);
				}
			}
			if ("auto" === params.slidesPerView && !params.loopedSlides) params.loopedSlides = slides.length;
			swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
			swiper.loopedSlides += params.loopAdditionalSlides;
			if (swiper.loopedSlides > slides.length && swiper.params.loopedSlidesLimit) swiper.loopedSlides = slides.length;
			const prependSlides = [];
			const appendSlides = [];
			slides.each(((el, index) => {
				dom(el).attr("data-swiper-slide-index", index);
			}));
			for (let i = 0; i < swiper.loopedSlides; i += 1) {
				const index = i - Math.floor(i / slides.length) * slides.length;
				appendSlides.push(slides.eq(index)[0]);
				prependSlides.unshift(slides.eq(slides.length - index - 1)[0]);
			}
			for (let i = 0; i < appendSlides.length; i += 1) $selector.append(dom(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
			for (let i = prependSlides.length - 1; i >= 0; i -= 1) $selector.prepend(dom(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
		}
		function loopFix() {
			const swiper = this;
			swiper.emit("beforeLoopFix");
			const { activeIndex, slides, loopedSlides, allowSlidePrev, allowSlideNext, snapGrid, rtlTranslate: rtl } = swiper;
			let newIndex;
			swiper.allowSlidePrev = true;
			swiper.allowSlideNext = true;
			const snapTranslate = -snapGrid[activeIndex];
			const diff = snapTranslate - swiper.getTranslate();
			if (activeIndex < loopedSlides) {
				newIndex = slides.length - 3 * loopedSlides + activeIndex;
				newIndex += loopedSlides;
				const slideChanged = swiper.slideTo(newIndex, 0, false, true);
				if (slideChanged && 0 !== diff) swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
			} else if (activeIndex >= slides.length - loopedSlides) {
				newIndex = -slides.length + activeIndex + loopedSlides;
				newIndex += loopedSlides;
				const slideChanged = swiper.slideTo(newIndex, 0, false, true);
				if (slideChanged && 0 !== diff) swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
			}
			swiper.allowSlidePrev = allowSlidePrev;
			swiper.allowSlideNext = allowSlideNext;
			swiper.emit("loopFix");
		}
		function loopDestroy() {
			const swiper = this;
			const { $wrapperEl, params, slides } = swiper;
			$wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
			slides.removeAttr("data-swiper-slide-index");
		}
		const loop = {
			loopCreate,
			loopFix,
			loopDestroy
		};
		function setGrabCursor(moving) {
			const swiper = this;
			if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
			const el = "container" === swiper.params.touchEventsTarget ? swiper.el : swiper.wrapperEl;
			el.style.cursor = "move";
			el.style.cursor = moving ? "grabbing" : "grab";
		}
		function unsetGrabCursor() {
			const swiper = this;
			if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
			swiper["container" === swiper.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "";
		}
		const grab_cursor = {
			setGrabCursor,
			unsetGrabCursor
		};
		function closestElement(selector, base) {
			if (void 0 === base) base = this;
			function __closestFrom(el) {
				if (!el || el === ssr_window_esm_getDocument() || el === ssr_window_esm_getWindow()) return null;
				if (el.assignedSlot) el = el.assignedSlot;
				const found = el.closest(selector);
				if (!found && !el.getRootNode) return null;
				return found || __closestFrom(el.getRootNode().host);
			}
			return __closestFrom(base);
		}
		function onTouchStart(event) {
			const swiper = this;
			const document = ssr_window_esm_getDocument();
			const window = ssr_window_esm_getWindow();
			const data = swiper.touchEventsData;
			const { params, touches, enabled } = swiper;
			if (!enabled) return;
			if (swiper.animating && params.preventInteractionOnTransition) return;
			if (!swiper.animating && params.cssMode && params.loop) swiper.loopFix();
			let e = event;
			if (e.originalEvent) e = e.originalEvent;
			let $targetEl = dom(e.target);
			if ("wrapper" === params.touchEventsTarget) if (!$targetEl.closest(swiper.wrapperEl).length) return;
			data.isTouchEvent = "touchstart" === e.type;
			if (!data.isTouchEvent && "which" in e && 3 === e.which) return;
			if (!data.isTouchEvent && "button" in e && e.button > 0) return;
			if (data.isTouched && data.isMoved) return;
			const swipingClassHasValue = !!params.noSwipingClass && "" !== params.noSwipingClass;
			if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) $targetEl = dom(event.path[0]);
			const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
			const isTargetShadow = !!(e.target && e.target.shadowRoot);
			if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, $targetEl[0]) : $targetEl.closest(noSwipingSelector)[0])) {
				swiper.allowClick = true;
				return;
			}
			if (params.swipeHandler) if (!$targetEl.closest(params.swipeHandler)[0]) return;
			touches.currentX = "touchstart" === e.type ? e.targetTouches[0].pageX : e.pageX;
			touches.currentY = "touchstart" === e.type ? e.targetTouches[0].pageY : e.pageY;
			const startX = touches.currentX;
			const startY = touches.currentY;
			const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
			const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
			if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) if ("prevent" === edgeSwipeDetection) event.preventDefault(); else return;
			Object.assign(data, {
				isTouched: true,
				isMoved: false,
				allowTouchCallbacks: true,
				isScrolling: void 0,
				startMoving: void 0
			});
			touches.startX = startX;
			touches.startY = startY;
			data.touchStartTime = utils_now();
			swiper.allowClick = true;
			swiper.updateSize();
			swiper.swipeDirection = void 0;
			if (params.threshold > 0) data.allowThresholdMove = false;
			if ("touchstart" !== e.type) {
				let preventDefault = true;
				if ($targetEl.is(data.focusableElements)) {
					preventDefault = false;
					if ("SELECT" === $targetEl[0].nodeName) data.isTouched = false;
				}
				if (document.activeElement && dom(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) document.activeElement.blur();
				const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
				if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) e.preventDefault();
			}
			if (swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) swiper.freeMode.onTouchStart();
			swiper.emit("touchStart", e);
		}
		function onTouchMove(event) {
			const document = ssr_window_esm_getDocument();
			const swiper = this;
			const data = swiper.touchEventsData;
			const { params, touches, rtlTranslate: rtl, enabled } = swiper;
			if (!enabled) return;
			let e = event;
			if (e.originalEvent) e = e.originalEvent;
			if (!data.isTouched) {
				if (data.startMoving && data.isScrolling) swiper.emit("touchMoveOpposite", e);
				return;
			}
			if (data.isTouchEvent && "touchmove" !== e.type) return;
			const targetTouch = "touchmove" === e.type && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
			const pageX = "touchmove" === e.type ? targetTouch.pageX : e.pageX;
			const pageY = "touchmove" === e.type ? targetTouch.pageY : e.pageY;
			if (e.preventedByNestedSwiper) {
				touches.startX = pageX;
				touches.startY = pageY;
				return;
			}
			if (!swiper.allowTouchMove) {
				if (!dom(e.target).is(data.focusableElements)) swiper.allowClick = false;
				if (data.isTouched) {
					Object.assign(touches, {
						startX: pageX,
						startY: pageY,
						currentX: pageX,
						currentY: pageY
					});
					data.touchStartTime = utils_now();
				}
				return;
			}
			if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) if (swiper.isVertical()) {
				if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
					data.isTouched = false;
					data.isMoved = false;
					return;
				}
			} else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) return;
			if (data.isTouchEvent && document.activeElement) if (e.target === document.activeElement && dom(e.target).is(data.focusableElements)) {
				data.isMoved = true;
				swiper.allowClick = false;
				return;
			}
			if (data.allowTouchCallbacks) swiper.emit("touchMove", e);
			if (e.targetTouches && e.targetTouches.length > 1) return;
			touches.currentX = pageX;
			touches.currentY = pageY;
			const diffX = touches.currentX - touches.startX;
			const diffY = touches.currentY - touches.startY;
			if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
			if ("undefined" === typeof data.isScrolling) {
				let touchAngle;
				if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) data.isScrolling = false; else if (diffX * diffX + diffY * diffY >= 25) {
					touchAngle = 180 * Math.atan2(Math.abs(diffY), Math.abs(diffX)) / Math.PI;
					data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
				}
			}
			if (data.isScrolling) swiper.emit("touchMoveOpposite", e);
			if ("undefined" === typeof data.startMoving) if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) data.startMoving = true;
			if (data.isScrolling) {
				data.isTouched = false;
				return;
			}
			if (!data.startMoving) return;
			swiper.allowClick = false;
			if (!params.cssMode && e.cancelable) e.preventDefault();
			if (params.touchMoveStopPropagation && !params.nested) e.stopPropagation();
			if (!data.isMoved) {
				if (params.loop && !params.cssMode) swiper.loopFix();
				data.startTranslate = swiper.getTranslate();
				swiper.setTransition(0);
				if (swiper.animating) swiper.$wrapperEl.trigger("webkitTransitionEnd transitionend");
				data.allowMomentumBounce = false;
				if (params.grabCursor && (true === swiper.allowSlideNext || true === swiper.allowSlidePrev)) swiper.setGrabCursor(true);
				swiper.emit("sliderFirstMove", e);
			}
			swiper.emit("sliderMove", e);
			data.isMoved = true;
			let diff = swiper.isHorizontal() ? diffX : diffY;
			touches.diff = diff;
			diff *= params.touchRatio;
			if (rtl) diff = -diff;
			swiper.swipeDirection = diff > 0 ? "prev" : "next";
			data.currentTranslate = diff + data.startTranslate;
			let disableParentSwiper = true;
			let resistanceRatio = params.resistanceRatio;
			if (params.touchReleaseOnEdges) resistanceRatio = 0;
			if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
				disableParentSwiper = false;
				if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
			} else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
				disableParentSwiper = false;
				if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
			}
			if (disableParentSwiper) e.preventedByNestedSwiper = true;
			if (!swiper.allowSlideNext && "next" === swiper.swipeDirection && data.currentTranslate < data.startTranslate) data.currentTranslate = data.startTranslate;
			if (!swiper.allowSlidePrev && "prev" === swiper.swipeDirection && data.currentTranslate > data.startTranslate) data.currentTranslate = data.startTranslate;
			if (!swiper.allowSlidePrev && !swiper.allowSlideNext) data.currentTranslate = data.startTranslate;
			if (params.threshold > 0) if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
				if (!data.allowThresholdMove) {
					data.allowThresholdMove = true;
					touches.startX = touches.currentX;
					touches.startY = touches.currentY;
					data.currentTranslate = data.startTranslate;
					touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
					return;
				}
			} else {
				data.currentTranslate = data.startTranslate;
				return;
			}
			if (!params.followFinger || params.cssMode) return;
			if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
				swiper.updateActiveIndex();
				swiper.updateSlidesClasses();
			}
			if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) swiper.freeMode.onTouchMove();
			swiper.updateProgress(data.currentTranslate);
			swiper.setTranslate(data.currentTranslate);
		}
		function onTouchEnd(event) {
			const swiper = this;
			const data = swiper.touchEventsData;
			const { params, touches, rtlTranslate: rtl, slidesGrid, enabled } = swiper;
			if (!enabled) return;
			let e = event;
			if (e.originalEvent) e = e.originalEvent;
			if (data.allowTouchCallbacks) swiper.emit("touchEnd", e);
			data.allowTouchCallbacks = false;
			if (!data.isTouched) {
				if (data.isMoved && params.grabCursor) swiper.setGrabCursor(false);
				data.isMoved = false;
				data.startMoving = false;
				return;
			}
			if (params.grabCursor && data.isMoved && data.isTouched && (true === swiper.allowSlideNext || true === swiper.allowSlidePrev)) swiper.setGrabCursor(false);
			const touchEndTime = utils_now();
			const timeDiff = touchEndTime - data.touchStartTime;
			if (swiper.allowClick) {
				const pathTree = e.path || e.composedPath && e.composedPath();
				swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);
				swiper.emit("tap click", e);
				if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) swiper.emit("doubleTap doubleClick", e);
			}
			data.lastClickTime = utils_now();
			utils_nextTick((() => {
				if (!swiper.destroyed) swiper.allowClick = true;
			}));
			if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || 0 === touches.diff || data.currentTranslate === data.startTranslate) {
				data.isTouched = false;
				data.isMoved = false;
				data.startMoving = false;
				return;
			}
			data.isTouched = false;
			data.isMoved = false;
			data.startMoving = false;
			let currentPos;
			if (params.followFinger) currentPos = rtl ? swiper.translate : -swiper.translate; else currentPos = -data.currentTranslate;
			if (params.cssMode) return;
			if (swiper.params.freeMode && params.freeMode.enabled) {
				swiper.freeMode.onTouchEnd({
					currentPos
				});
				return;
			}
			let stopIndex = 0;
			let groupSize = swiper.slidesSizesGrid[0];
			for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
				const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
				if ("undefined" !== typeof slidesGrid[i + increment]) {
					if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
						stopIndex = i;
						groupSize = slidesGrid[i + increment] - slidesGrid[i];
					}
				} else if (currentPos >= slidesGrid[i]) {
					stopIndex = i;
					groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
				}
			}
			let rewindFirstIndex = null;
			let rewindLastIndex = null;
			if (params.rewind) if (swiper.isBeginning) rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1; else if (swiper.isEnd) rewindFirstIndex = 0;
			const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
			const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
			if (timeDiff > params.longSwipesMs) {
				if (!params.longSwipes) {
					swiper.slideTo(swiper.activeIndex);
					return;
				}
				if ("next" === swiper.swipeDirection) if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment); else swiper.slideTo(stopIndex);
				if ("prev" === swiper.swipeDirection) if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment); else if (null !== rewindLastIndex && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) swiper.slideTo(rewindLastIndex); else swiper.slideTo(stopIndex);
			} else {
				if (!params.shortSwipes) {
					swiper.slideTo(swiper.activeIndex);
					return;
				}
				const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
				if (!isNavButtonTarget) {
					if ("next" === swiper.swipeDirection) swiper.slideTo(null !== rewindFirstIndex ? rewindFirstIndex : stopIndex + increment);
					if ("prev" === swiper.swipeDirection) swiper.slideTo(null !== rewindLastIndex ? rewindLastIndex : stopIndex);
				} else if (e.target === swiper.navigation.nextEl) swiper.slideTo(stopIndex + increment); else swiper.slideTo(stopIndex);
			}
		}
		function onResize() {
			const swiper = this;
			const { params, el } = swiper;
			if (el && 0 === el.offsetWidth) return;
			if (params.breakpoints) swiper.setBreakpoint();
			const { allowSlideNext, allowSlidePrev, snapGrid } = swiper;
			swiper.allowSlideNext = true;
			swiper.allowSlidePrev = true;
			swiper.updateSize();
			swiper.updateSlides();
			swiper.updateSlidesClasses();
			if (("auto" === params.slidesPerView || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) swiper.slideTo(swiper.slides.length - 1, 0, false, true); else swiper.slideTo(swiper.activeIndex, 0, false, true);
			if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) swiper.autoplay.run();
			swiper.allowSlidePrev = allowSlidePrev;
			swiper.allowSlideNext = allowSlideNext;
			if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();
		}
		function onClick(e) {
			const swiper = this;
			if (!swiper.enabled) return;
			if (!swiper.allowClick) {
				if (swiper.params.preventClicks) e.preventDefault();
				if (swiper.params.preventClicksPropagation && swiper.animating) {
					e.stopPropagation();
					e.stopImmediatePropagation();
				}
			}
		}
		function onScroll() {
			const swiper = this;
			const { wrapperEl, rtlTranslate, enabled } = swiper;
			if (!enabled) return;
			swiper.previousTranslate = swiper.translate;
			if (swiper.isHorizontal()) swiper.translate = -wrapperEl.scrollLeft; else swiper.translate = -wrapperEl.scrollTop;
			if (0 === swiper.translate) swiper.translate = 0;
			swiper.updateActiveIndex();
			swiper.updateSlidesClasses();
			let newProgress;
			const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
			if (0 === translatesDiff) newProgress = 0; else newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
			if (newProgress !== swiper.progress) swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
			swiper.emit("setTranslate", swiper.translate, false);
		}
		let dummyEventAttached = false;
		function dummyEventListener() { }
		const events = (swiper, method) => {
			const document = ssr_window_esm_getDocument();
			const { params, touchEvents, el, wrapperEl, device, support } = swiper;
			const capture = !!params.nested;
			const domMethod = "on" === method ? "addEventListener" : "removeEventListener";
			const swiperMethod = method;
			if (!support.touch) {
				el[domMethod](touchEvents.start, swiper.onTouchStart, false);
				document[domMethod](touchEvents.move, swiper.onTouchMove, capture);
				document[domMethod](touchEvents.end, swiper.onTouchEnd, false);
			} else {
				const passiveListener = "touchstart" === touchEvents.start && support.passiveListener && params.passiveListeners ? {
					passive: true,
					capture: false
				} : false;
				el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);
				el[domMethod](touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
					passive: false,
					capture
				} : capture);
				el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);
				if (touchEvents.cancel) el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);
			}
			if (params.preventClicks || params.preventClicksPropagation) el[domMethod]("click", swiper.onClick, true);
			if (params.cssMode) wrapperEl[domMethod]("scroll", swiper.onScroll);
			if (params.updateOnWindowResize) swiper[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true); else swiper[swiperMethod]("observerUpdate", onResize, true);
		};
		function attachEvents() {
			const swiper = this;
			const document = ssr_window_esm_getDocument();
			const { params, support } = swiper;
			swiper.onTouchStart = onTouchStart.bind(swiper);
			swiper.onTouchMove = onTouchMove.bind(swiper);
			swiper.onTouchEnd = onTouchEnd.bind(swiper);
			if (params.cssMode) swiper.onScroll = onScroll.bind(swiper);
			swiper.onClick = onClick.bind(swiper);
			if (support.touch && !dummyEventAttached) {
				document.addEventListener("touchstart", dummyEventListener);
				dummyEventAttached = true;
			}
			events(swiper, "on");
		}
		function detachEvents() {
			const swiper = this;
			events(swiper, "off");
		}
		const core_events = {
			attachEvents,
			detachEvents
		};
		const isGridEnabled = (swiper, params) => swiper.grid && params.grid && params.grid.rows > 1;
		function setBreakpoint() {
			const swiper = this;
			const { activeIndex, initialized, loopedSlides = 0, params, $el } = swiper;
			const breakpoints = params.breakpoints;
			if (!breakpoints || breakpoints && 0 === Object.keys(breakpoints).length) return;
			const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
			if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
			const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : void 0;
			const breakpointParams = breakpointOnlyParams || swiper.originalParams;
			const wasMultiRow = isGridEnabled(swiper, params);
			const isMultiRow = isGridEnabled(swiper, breakpointParams);
			const wasEnabled = params.enabled;
			if (wasMultiRow && !isMultiRow) {
				$el.removeClass(`${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`);
				swiper.emitContainerClasses();
			} else if (!wasMultiRow && isMultiRow) {
				$el.addClass(`${params.containerModifierClass}grid`);
				if (breakpointParams.grid.fill && "column" === breakpointParams.grid.fill || !breakpointParams.grid.fill && "column" === params.grid.fill) $el.addClass(`${params.containerModifierClass}grid-column`);
				swiper.emitContainerClasses();
			}
			["navigation", "pagination", "scrollbar"].forEach((prop => {
				const wasModuleEnabled = params[prop] && params[prop].enabled;
				const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
				if (wasModuleEnabled && !isModuleEnabled) swiper[prop].disable();
				if (!wasModuleEnabled && isModuleEnabled) swiper[prop].enable();
			}));
			const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
			const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
			if (directionChanged && initialized) swiper.changeDirection();
			utils_extend(swiper.params, breakpointParams);
			const isEnabled = swiper.params.enabled;
			Object.assign(swiper, {
				allowTouchMove: swiper.params.allowTouchMove,
				allowSlideNext: swiper.params.allowSlideNext,
				allowSlidePrev: swiper.params.allowSlidePrev
			});
			if (wasEnabled && !isEnabled) swiper.disable(); else if (!wasEnabled && isEnabled) swiper.enable();
			swiper.currentBreakpoint = breakpoint;
			swiper.emit("_beforeBreakpoint", breakpointParams);
			if (needsReLoop && initialized) {
				swiper.loopDestroy();
				swiper.loopCreate();
				swiper.updateSlides();
				swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
			}
			swiper.emit("breakpoint", breakpointParams);
		}
		function getBreakpoint(breakpoints, base, containerEl) {
			if (void 0 === base) base = "window";
			if (!breakpoints || "container" === base && !containerEl) return;
			let breakpoint = false;
			const window = ssr_window_esm_getWindow();
			const currentHeight = "window" === base ? window.innerHeight : containerEl.clientHeight;
			const points = Object.keys(breakpoints).map((point => {
				if ("string" === typeof point && 0 === point.indexOf("@")) {
					const minRatio = parseFloat(point.substr(1));
					const value = currentHeight * minRatio;
					return {
						value,
						point
					};
				}
				return {
					value: point,
					point
				};
			}));
			points.sort(((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10)));
			for (let i = 0; i < points.length; i += 1) {
				const { point, value } = points[i];
				if ("window" === base) {
					if (window.matchMedia(`(min-width: ${value}px)`).matches) breakpoint = point;
				} else if (value <= containerEl.clientWidth) breakpoint = point;
			}
			return breakpoint || "max";
		}
		const breakpoints = {
			setBreakpoint,
			getBreakpoint
		};
		function prepareClasses(entries, prefix) {
			const resultClasses = [];
			entries.forEach((item => {
				if ("object" === typeof item) Object.keys(item).forEach((classNames => {
					if (item[classNames]) resultClasses.push(prefix + classNames);
				})); else if ("string" === typeof item) resultClasses.push(prefix + item);
			}));
			return resultClasses;
		}
		function addClasses() {
			const swiper = this;
			const { classNames, params, rtl, $el, device, support } = swiper;
			const suffixes = prepareClasses(["initialized", params.direction, {
				"pointer-events": !support.touch
			}, {
					"free-mode": swiper.params.freeMode && params.freeMode.enabled
				}, {
					autoheight: params.autoHeight
				}, {
					rtl
				}, {
					grid: params.grid && params.grid.rows > 1
				}, {
					"grid-column": params.grid && params.grid.rows > 1 && "column" === params.grid.fill
				}, {
					android: device.android
				}, {
					ios: device.ios
				}, {
					"css-mode": params.cssMode
				}, {
					centered: params.cssMode && params.centeredSlides
				}, {
					"watch-progress": params.watchSlidesProgress
				}], params.containerModifierClass);
			classNames.push(...suffixes);
			$el.addClass([...classNames].join(" "));
			swiper.emitContainerClasses();
		}
		function removeClasses() {
			const swiper = this;
			const { $el, classNames } = swiper;
			$el.removeClass(classNames.join(" "));
			swiper.emitContainerClasses();
		}
		const classes = {
			addClasses,
			removeClasses
		};
		function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
			const window = ssr_window_esm_getWindow();
			let image;
			function onReady() {
				if (callback) callback();
			}
			const isPicture = dom(imageEl).parent("picture")[0];
			if (!isPicture && (!imageEl.complete || !checkForComplete)) if (src) {
				image = new window.Image;
				image.onload = onReady;
				image.onerror = onReady;
				if (sizes) image.sizes = sizes;
				if (srcset) image.srcset = srcset;
				if (src) image.src = src;
			} else onReady(); else onReady();
		}
		function preloadImages() {
			const swiper = this;
			swiper.imagesToLoad = swiper.$el.find("img");
			function onReady() {
				if ("undefined" === typeof swiper || null === swiper || !swiper || swiper.destroyed) return;
				if (void 0 !== swiper.imagesLoaded) swiper.imagesLoaded += 1;
				if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
					if (swiper.params.updateOnImagesReady) swiper.update();
					swiper.emit("imagesReady");
				}
			}
			for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
				const imageEl = swiper.imagesToLoad[i];
				swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute("src"), imageEl.srcset || imageEl.getAttribute("srcset"), imageEl.sizes || imageEl.getAttribute("sizes"), true, onReady);
			}
		}
		const core_images = {
			loadImage,
			preloadImages
		};
		function checkOverflow() {
			const swiper = this;
			const { isLocked: wasLocked, params } = swiper;
			const { slidesOffsetBefore } = params;
			if (slidesOffsetBefore) {
				const lastSlideIndex = swiper.slides.length - 1;
				const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + 2 * slidesOffsetBefore;
				swiper.isLocked = swiper.size > lastSlideRightEdge;
			} else swiper.isLocked = 1 === swiper.snapGrid.length;
			if (true === params.allowSlideNext) swiper.allowSlideNext = !swiper.isLocked;
			if (true === params.allowSlidePrev) swiper.allowSlidePrev = !swiper.isLocked;
			if (wasLocked && wasLocked !== swiper.isLocked) swiper.isEnd = false;
			if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? "lock" : "unlock");
		}
		const check_overflow = {
			checkOverflow
		};
		const defaults = {
			init: true,
			direction: "horizontal",
			touchEventsTarget: "wrapper",
			initialSlide: 0,
			speed: 300,
			cssMode: false,
			updateOnWindowResize: true,
			resizeObserver: true,
			nested: false,
			createElements: false,
			enabled: true,
			focusableElements: "input, select, option, textarea, button, video, label",
			width: null,
			height: null,
			preventInteractionOnTransition: false,
			userAgent: null,
			url: null,
			edgeSwipeDetection: false,
			edgeSwipeThreshold: 20,
			autoHeight: false,
			setWrapperSize: false,
			virtualTranslate: false,
			effect: "slide",
			breakpoints: void 0,
			breakpointsBase: "window",
			spaceBetween: 0,
			slidesPerView: 1,
			slidesPerGroup: 1,
			slidesPerGroupSkip: 0,
			slidesPerGroupAuto: false,
			centeredSlides: false,
			centeredSlidesBounds: false,
			slidesOffsetBefore: 0,
			slidesOffsetAfter: 0,
			normalizeSlideIndex: true,
			centerInsufficientSlides: false,
			watchOverflow: true,
			roundLengths: false,
			touchRatio: 1,
			touchAngle: 45,
			simulateTouch: true,
			shortSwipes: true,
			longSwipes: true,
			longSwipesRatio: .5,
			longSwipesMs: 300,
			followFinger: true,
			allowTouchMove: true,
			threshold: 0,
			touchMoveStopPropagation: false,
			touchStartPreventDefault: true,
			touchStartForcePreventDefault: false,
			touchReleaseOnEdges: false,
			uniqueNavElements: true,
			resistance: true,
			resistanceRatio: .85,
			watchSlidesProgress: false,
			grabCursor: false,
			preventClicks: true,
			preventClicksPropagation: true,
			slideToClickedSlide: false,
			preloadImages: true,
			updateOnImagesReady: true,
			loop: false,
			loopAdditionalSlides: 0,
			loopedSlides: null,
			loopedSlidesLimit: true,
			loopFillGroupWithBlank: false,
			loopPreventsSlide: true,
			rewind: false,
			allowSlidePrev: true,
			allowSlideNext: true,
			swipeHandler: null,
			noSwiping: true,
			noSwipingClass: "swiper-no-swiping",
			noSwipingSelector: null,
			passiveListeners: true,
			maxBackfaceHiddenSlides: 10,
			containerModifierClass: "swiper-",
			slideClass: "swiper-slide",
			slideBlankClass: "swiper-slide-invisible-blank",
			slideActiveClass: "swiper-slide-active",
			slideDuplicateActiveClass: "swiper-slide-duplicate-active",
			slideVisibleClass: "swiper-slide-visible",
			slideDuplicateClass: "swiper-slide-duplicate",
			slideNextClass: "swiper-slide-next",
			slideDuplicateNextClass: "swiper-slide-duplicate-next",
			slidePrevClass: "swiper-slide-prev",
			slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
			wrapperClass: "swiper-wrapper",
			runCallbacksOnInit: true,
			_emitClasses: false
		};
		function moduleExtendParams(params, allModulesParams) {
			return function extendParams(obj) {
				if (void 0 === obj) obj = {};
				const moduleParamName = Object.keys(obj)[0];
				const moduleParams = obj[moduleParamName];
				if ("object" !== typeof moduleParams || null === moduleParams) {
					utils_extend(allModulesParams, obj);
					return;
				}
				if (["navigation", "pagination", "scrollbar"].indexOf(moduleParamName) >= 0 && true === params[moduleParamName]) params[moduleParamName] = {
					auto: true
				};
				if (!(moduleParamName in params && "enabled" in moduleParams)) {
					utils_extend(allModulesParams, obj);
					return;
				}
				if (true === params[moduleParamName]) params[moduleParamName] = {
					enabled: true
				};
				if ("object" === typeof params[moduleParamName] && !("enabled" in params[moduleParamName])) params[moduleParamName].enabled = true;
				if (!params[moduleParamName]) params[moduleParamName] = {
					enabled: false
				};
				utils_extend(allModulesParams, obj);
			};
		}
		const prototypes = {
			eventsEmitter: events_emitter,
			update,
			translate,
			transition: core_transition,
			slide,
			loop,
			grabCursor: grab_cursor,
			events: core_events,
			breakpoints,
			checkOverflow: check_overflow,
			classes,
			images: core_images
		};
		const extendedDefaults = {};
		class Swiper {
			constructor() {
				let el;
				let params;
				for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
				if (1 === args.length && args[0].constructor && "Object" === Object.prototype.toString.call(args[0]).slice(8, -1)) params = args[0]; else[el, params] = args;
				if (!params) params = {};
				params = utils_extend({}, params);
				if (el && !params.el) params.el = el;
				if (params.el && dom(params.el).length > 1) {
					const swipers = [];
					dom(params.el).each((containerEl => {
						const newParams = utils_extend({}, params, {
							el: containerEl
						});
						swipers.push(new Swiper(newParams));
					}));
					return swipers;
				}
				const swiper = this;
				swiper.__swiper__ = true;
				swiper.support = getSupport();
				swiper.device = getDevice({
					userAgent: params.userAgent
				});
				swiper.browser = getBrowser();
				swiper.eventsListeners = {};
				swiper.eventsAnyListeners = [];
				swiper.modules = [...swiper.__modules__];
				if (params.modules && Array.isArray(params.modules)) swiper.modules.push(...params.modules);
				const allModulesParams = {};
				swiper.modules.forEach((mod => {
					mod({
						swiper,
						extendParams: moduleExtendParams(params, allModulesParams),
						on: swiper.on.bind(swiper),
						once: swiper.once.bind(swiper),
						off: swiper.off.bind(swiper),
						emit: swiper.emit.bind(swiper)
					});
				}));
				const swiperParams = utils_extend({}, defaults, allModulesParams);
				swiper.params = utils_extend({}, swiperParams, extendedDefaults, params);
				swiper.originalParams = utils_extend({}, swiper.params);
				swiper.passedParams = utils_extend({}, params);
				if (swiper.params && swiper.params.on) Object.keys(swiper.params.on).forEach((eventName => {
					swiper.on(eventName, swiper.params.on[eventName]);
				}));
				if (swiper.params && swiper.params.onAny) swiper.onAny(swiper.params.onAny);
				swiper.$ = dom;
				Object.assign(swiper, {
					enabled: swiper.params.enabled,
					el,
					classNames: [],
					slides: dom(),
					slidesGrid: [],
					snapGrid: [],
					slidesSizesGrid: [],
					isHorizontal() {
						return "horizontal" === swiper.params.direction;
					},
					isVertical() {
						return "vertical" === swiper.params.direction;
					},
					activeIndex: 0,
					realIndex: 0,
					isBeginning: true,
					isEnd: false,
					translate: 0,
					previousTranslate: 0,
					progress: 0,
					velocity: 0,
					animating: false,
					allowSlideNext: swiper.params.allowSlideNext,
					allowSlidePrev: swiper.params.allowSlidePrev,
					touchEvents: function touchEvents() {
						const touch = ["touchstart", "touchmove", "touchend", "touchcancel"];
						const desktop = ["pointerdown", "pointermove", "pointerup"];
						swiper.touchEventsTouch = {
							start: touch[0],
							move: touch[1],
							end: touch[2],
							cancel: touch[3]
						};
						swiper.touchEventsDesktop = {
							start: desktop[0],
							move: desktop[1],
							end: desktop[2]
						};
						return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
					}(),
					touchEventsData: {
						isTouched: void 0,
						isMoved: void 0,
						allowTouchCallbacks: void 0,
						touchStartTime: void 0,
						isScrolling: void 0,
						currentTranslate: void 0,
						startTranslate: void 0,
						allowThresholdMove: void 0,
						focusableElements: swiper.params.focusableElements,
						lastClickTime: utils_now(),
						clickTimeout: void 0,
						velocities: [],
						allowMomentumBounce: void 0,
						isTouchEvent: void 0,
						startMoving: void 0
					},
					allowClick: true,
					allowTouchMove: swiper.params.allowTouchMove,
					touches: {
						startX: 0,
						startY: 0,
						currentX: 0,
						currentY: 0,
						diff: 0
					},
					imagesToLoad: [],
					imagesLoaded: 0
				});
				swiper.emit("_swiper");
				if (swiper.params.init) swiper.init();
				return swiper;
			}
			enable() {
				const swiper = this;
				if (swiper.enabled) return;
				swiper.enabled = true;
				if (swiper.params.grabCursor) swiper.setGrabCursor();
				swiper.emit("enable");
			}
			disable() {
				const swiper = this;
				if (!swiper.enabled) return;
				swiper.enabled = false;
				if (swiper.params.grabCursor) swiper.unsetGrabCursor();
				swiper.emit("disable");
			}
			setProgress(progress, speed) {
				const swiper = this;
				progress = Math.min(Math.max(progress, 0), 1);
				const min = swiper.minTranslate();
				const max = swiper.maxTranslate();
				const current = (max - min) * progress + min;
				swiper.translateTo(current, "undefined" === typeof speed ? 0 : speed);
				swiper.updateActiveIndex();
				swiper.updateSlidesClasses();
			}
			emitContainerClasses() {
				const swiper = this;
				if (!swiper.params._emitClasses || !swiper.el) return;
				const cls = swiper.el.className.split(" ").filter((className => 0 === className.indexOf("swiper") || 0 === className.indexOf(swiper.params.containerModifierClass)));
				swiper.emit("_containerClasses", cls.join(" "));
			}
			getSlideClasses(slideEl) {
				const swiper = this;
				if (swiper.destroyed) return "";
				return slideEl.className.split(" ").filter((className => 0 === className.indexOf("swiper-slide") || 0 === className.indexOf(swiper.params.slideClass))).join(" ");
			}
			emitSlidesClasses() {
				const swiper = this;
				if (!swiper.params._emitClasses || !swiper.el) return;
				const updates = [];
				swiper.slides.each((slideEl => {
					const classNames = swiper.getSlideClasses(slideEl);
					updates.push({
						slideEl,
						classNames
					});
					swiper.emit("_slideClass", slideEl, classNames);
				}));
				swiper.emit("_slideClasses", updates);
			}
			slidesPerViewDynamic(view, exact) {
				if (void 0 === view) view = "current";
				if (void 0 === exact) exact = false;
				const swiper = this;
				const { params, slides, slidesGrid, slidesSizesGrid, size: swiperSize, activeIndex } = swiper;
				let spv = 1;
				if (params.centeredSlides) {
					let slideSize = slides[activeIndex].swiperSlideSize;
					let breakLoop;
					for (let i = activeIndex + 1; i < slides.length; i += 1) if (slides[i] && !breakLoop) {
						slideSize += slides[i].swiperSlideSize;
						spv += 1;
						if (slideSize > swiperSize) breakLoop = true;
					}
					for (let i = activeIndex - 1; i >= 0; i -= 1) if (slides[i] && !breakLoop) {
						slideSize += slides[i].swiperSlideSize;
						spv += 1;
						if (slideSize > swiperSize) breakLoop = true;
					}
				} else if ("current" === view) for (let i = activeIndex + 1; i < slides.length; i += 1) {
					const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
					if (slideInView) spv += 1;
				} else for (let i = activeIndex - 1; i >= 0; i -= 1) {
					const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
					if (slideInView) spv += 1;
				}
				return spv;
			}
			update() {
				const swiper = this;
				if (!swiper || swiper.destroyed) return;
				const { snapGrid, params } = swiper;
				if (params.breakpoints) swiper.setBreakpoint();
				swiper.updateSize();
				swiper.updateSlides();
				swiper.updateProgress();
				swiper.updateSlidesClasses();
				function setTranslate() {
					const translateValue = swiper.rtlTranslate ? -1 * swiper.translate : swiper.translate;
					const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
					swiper.setTranslate(newTranslate);
					swiper.updateActiveIndex();
					swiper.updateSlidesClasses();
				}
				let translated;
				if (swiper.params.freeMode && swiper.params.freeMode.enabled) {
					setTranslate();
					if (swiper.params.autoHeight) swiper.updateAutoHeight();
				} else {
					if (("auto" === swiper.params.slidesPerView || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true); else translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
					if (!translated) setTranslate();
				}
				if (params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();
				swiper.emit("update");
			}
			changeDirection(newDirection, needUpdate) {
				if (void 0 === needUpdate) needUpdate = true;
				const swiper = this;
				const currentDirection = swiper.params.direction;
				if (!newDirection) newDirection = "horizontal" === currentDirection ? "vertical" : "horizontal";
				if (newDirection === currentDirection || "horizontal" !== newDirection && "vertical" !== newDirection) return swiper;
				swiper.$el.removeClass(`${swiper.params.containerModifierClass}${currentDirection}`).addClass(`${swiper.params.containerModifierClass}${newDirection}`);
				swiper.emitContainerClasses();
				swiper.params.direction = newDirection;
				swiper.slides.each((slideEl => {
					if ("vertical" === newDirection) slideEl.style.width = ""; else slideEl.style.height = "";
				}));
				swiper.emit("changeDirection");
				if (needUpdate) swiper.update();
				return swiper;
			}
			changeLanguageDirection(direction) {
				const swiper = this;
				if (swiper.rtl && "rtl" === direction || !swiper.rtl && "ltr" === direction) return;
				swiper.rtl = "rtl" === direction;
				swiper.rtlTranslate = "horizontal" === swiper.params.direction && swiper.rtl;
				if (swiper.rtl) {
					swiper.$el.addClass(`${swiper.params.containerModifierClass}rtl`);
					swiper.el.dir = "rtl";
				} else {
					swiper.$el.removeClass(`${swiper.params.containerModifierClass}rtl`);
					swiper.el.dir = "ltr";
				}
				swiper.update();
			}
			mount(el) {
				const swiper = this;
				if (swiper.mounted) return true;
				const $el = dom(el || swiper.params.el);
				el = $el[0];
				if (!el) return false;
				el.swiper = swiper;
				const getWrapperSelector = () => `.${(swiper.params.wrapperClass || "").trim().split(" ").join(".")}`;
				const getWrapper = () => {
					if (el && el.shadowRoot && el.shadowRoot.querySelector) {
						const res = dom(el.shadowRoot.querySelector(getWrapperSelector()));
						res.children = options => $el.children(options);
						return res;
					}
					if (!$el.children) return dom($el).children(getWrapperSelector());
					return $el.children(getWrapperSelector());
				};
				let $wrapperEl = getWrapper();
				if (0 === $wrapperEl.length && swiper.params.createElements) {
					const document = ssr_window_esm_getDocument();
					const wrapper = document.createElement("div");
					$wrapperEl = dom(wrapper);
					wrapper.className = swiper.params.wrapperClass;
					$el.append(wrapper);
					$el.children(`.${swiper.params.slideClass}`).each((slideEl => {
						$wrapperEl.append(slideEl);
					}));
				}
				Object.assign(swiper, {
					$el,
					el,
					$wrapperEl,
					wrapperEl: $wrapperEl[0],
					mounted: true,
					rtl: "rtl" === el.dir.toLowerCase() || "rtl" === $el.css("direction"),
					rtlTranslate: "horizontal" === swiper.params.direction && ("rtl" === el.dir.toLowerCase() || "rtl" === $el.css("direction")),
					wrongRTL: "-webkit-box" === $wrapperEl.css("display")
				});
				return true;
			}
			init(el) {
				const swiper = this;
				if (swiper.initialized) return swiper;
				const mounted = swiper.mount(el);
				if (false === mounted) return swiper;
				swiper.emit("beforeInit");
				if (swiper.params.breakpoints) swiper.setBreakpoint();
				swiper.addClasses();
				if (swiper.params.loop) swiper.loopCreate();
				swiper.updateSize();
				swiper.updateSlides();
				if (swiper.params.watchOverflow) swiper.checkOverflow();
				if (swiper.params.grabCursor && swiper.enabled) swiper.setGrabCursor();
				if (swiper.params.preloadImages) swiper.preloadImages();
				if (swiper.params.loop) swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true); else swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
				swiper.attachEvents();
				swiper.initialized = true;
				swiper.emit("init");
				swiper.emit("afterInit");
				return swiper;
			}
			destroy(deleteInstance, cleanStyles) {
				if (void 0 === deleteInstance) deleteInstance = true;
				if (void 0 === cleanStyles) cleanStyles = true;
				const swiper = this;
				const { params, $el, $wrapperEl, slides } = swiper;
				if ("undefined" === typeof swiper.params || swiper.destroyed) return null;
				swiper.emit("beforeDestroy");
				swiper.initialized = false;
				swiper.detachEvents();
				if (params.loop) swiper.loopDestroy();
				if (cleanStyles) {
					swiper.removeClasses();
					$el.removeAttr("style");
					$wrapperEl.removeAttr("style");
					if (slides && slides.length) slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index");
				}
				swiper.emit("destroy");
				Object.keys(swiper.eventsListeners).forEach((eventName => {
					swiper.off(eventName);
				}));
				if (false !== deleteInstance) {
					swiper.$el[0].swiper = null;
					deleteProps(swiper);
				}
				swiper.destroyed = true;
				return null;
			}
			static extendDefaults(newDefaults) {
				utils_extend(extendedDefaults, newDefaults);
			}
			static get extendedDefaults() {
				return extendedDefaults;
			}
			static get defaults() {
				return defaults;
			}
			static installModule(mod) {
				if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
				const modules = Swiper.prototype.__modules__;
				if ("function" === typeof mod && modules.indexOf(mod) < 0) modules.push(mod);
			}
			static use(module) {
				if (Array.isArray(module)) {
					module.forEach((m => Swiper.installModule(m)));
					return Swiper;
				}
				Swiper.installModule(module);
				return Swiper;
			}
		}
		Object.keys(prototypes).forEach((prototypeGroup => {
			Object.keys(prototypes[prototypeGroup]).forEach((protoMethod => {
				Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
			}));
		}));
		Swiper.use([Resize, Observer]);
		const core = Swiper;
		function create_element_if_not_defined_createElementIfNotDefined(swiper, originalParams, params, checkProps) {
			const document = ssr_window_esm_getDocument();
			if (swiper.params.createElements) Object.keys(checkProps).forEach((key => {
				if (!params[key] && true === params.auto) {
					let element = swiper.$el.children(`.${checkProps[key]}`)[0];
					if (!element) {
						element = document.createElement("div");
						element.className = checkProps[key];
						swiper.$el.append(element);
					}
					params[key] = element;
					originalParams[key] = element;
				}
			}));
			return params;
		}
		function Navigation(_ref) {
			let { swiper, extendParams, on, emit } = _ref;
			extendParams({
				navigation: {
					nextEl: null,
					prevEl: null,
					hideOnClick: false,
					disabledClass: "swiper-button-disabled",
					hiddenClass: "swiper-button-hidden",
					lockClass: "swiper-button-lock",
					navigationDisabledClass: "swiper-navigation-disabled"
				}
			});
			swiper.navigation = {
				nextEl: null,
				$nextEl: null,
				prevEl: null,
				$prevEl: null
			};
			function getEl(el) {
				let $el;
				if (el) {
					$el = dom(el);
					if (swiper.params.uniqueNavElements && "string" === typeof el && $el.length > 1 && 1 === swiper.$el.find(el).length) $el = swiper.$el.find(el);
				}
				return $el;
			}
			function toggleEl($el, disabled) {
				const params = swiper.params.navigation;
				if ($el && $el.length > 0) {
					$el[disabled ? "addClass" : "removeClass"](params.disabledClass);
					if ($el[0] && "BUTTON" === $el[0].tagName) $el[0].disabled = disabled;
					if (swiper.params.watchOverflow && swiper.enabled) $el[swiper.isLocked ? "addClass" : "removeClass"](params.lockClass);
				}
			}
			function update() {
				if (swiper.params.loop) return;
				const { $nextEl, $prevEl } = swiper.navigation;
				toggleEl($prevEl, swiper.isBeginning && !swiper.params.rewind);
				toggleEl($nextEl, swiper.isEnd && !swiper.params.rewind);
			}
			function onPrevClick(e) {
				e.preventDefault();
				if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
				swiper.slidePrev();
				emit("navigationPrev");
			}
			function onNextClick(e) {
				e.preventDefault();
				if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
				swiper.slideNext();
				emit("navigationNext");
			}
			function init() {
				const params = swiper.params.navigation;
				swiper.params.navigation = create_element_if_not_defined_createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
					nextEl: "swiper-button-next",
					prevEl: "swiper-button-prev"
				});
				if (!(params.nextEl || params.prevEl)) return;
				const $nextEl = getEl(params.nextEl);
				const $prevEl = getEl(params.prevEl);
				if ($nextEl && $nextEl.length > 0) $nextEl.on("click", onNextClick);
				if ($prevEl && $prevEl.length > 0) $prevEl.on("click", onPrevClick);
				Object.assign(swiper.navigation, {
					$nextEl,
					nextEl: $nextEl && $nextEl[0],
					$prevEl,
					prevEl: $prevEl && $prevEl[0]
				});
				if (!swiper.enabled) {
					if ($nextEl) $nextEl.addClass(params.lockClass);
					if ($prevEl) $prevEl.addClass(params.lockClass);
				}
			}
			function destroy() {
				const { $nextEl, $prevEl } = swiper.navigation;
				if ($nextEl && $nextEl.length) {
					$nextEl.off("click", onNextClick);
					$nextEl.removeClass(swiper.params.navigation.disabledClass);
				}
				if ($prevEl && $prevEl.length) {
					$prevEl.off("click", onPrevClick);
					$prevEl.removeClass(swiper.params.navigation.disabledClass);
				}
			}
			on("init", (() => {
				if (false === swiper.params.navigation.enabled) disable(); else {
					init();
					update();
				}
			}));
			on("toEdge fromEdge lock unlock", (() => {
				update();
			}));
			on("destroy", (() => {
				destroy();
			}));
			on("enable disable", (() => {
				const { $nextEl, $prevEl } = swiper.navigation;
				if ($nextEl) $nextEl[swiper.enabled ? "removeClass" : "addClass"](swiper.params.navigation.lockClass);
				if ($prevEl) $prevEl[swiper.enabled ? "removeClass" : "addClass"](swiper.params.navigation.lockClass);
			}));
			on("click", ((_s, e) => {
				const { $nextEl, $prevEl } = swiper.navigation;
				const targetEl = e.target;
				if (swiper.params.navigation.hideOnClick && !dom(targetEl).is($prevEl) && !dom(targetEl).is($nextEl)) {
					if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
					let isHidden;
					if ($nextEl) isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass); else if ($prevEl) isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
					if (true === isHidden) emit("navigationShow"); else emit("navigationHide");
					if ($nextEl) $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
					if ($prevEl) $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
				}
			}));
			const enable = () => {
				swiper.$el.removeClass(swiper.params.navigation.navigationDisabledClass);
				init();
				update();
			};
			const disable = () => {
				swiper.$el.addClass(swiper.params.navigation.navigationDisabledClass);
				destroy();
			};
			Object.assign(swiper.navigation, {
				enable,
				disable,
				update,
				init,
				destroy
			});
		}
		function classes_to_selector_classesToSelector(classes) {
			if (void 0 === classes) classes = "";
			return `.${classes.trim().replace(/([\.:!\/])/g, "\\$1").replace(/ /g, ".")}`;
		}
		function Pagination(_ref) {
			let { swiper, extendParams, on, emit } = _ref;
			const pfx = "swiper-pagination";
			extendParams({
				pagination: {
					el: null,
					bulletElement: "span",
					clickable: false,
					hideOnClick: false,
					renderBullet: null,
					renderProgressbar: null,
					renderFraction: null,
					renderCustom: null,
					progressbarOpposite: false,
					type: "bullets",
					dynamicBullets: false,
					dynamicMainBullets: 1,
					formatFractionCurrent: number => number,
					formatFractionTotal: number => number,
					bulletClass: `${pfx}-bullet`,
					bulletActiveClass: `${pfx}-bullet-active`,
					modifierClass: `${pfx}-`,
					currentClass: `${pfx}-current`,
					totalClass: `${pfx}-total`,
					hiddenClass: `${pfx}-hidden`,
					progressbarFillClass: `${pfx}-progressbar-fill`,
					progressbarOppositeClass: `${pfx}-progressbar-opposite`,
					clickableClass: `${pfx}-clickable`,
					lockClass: `${pfx}-lock`,
					horizontalClass: `${pfx}-horizontal`,
					verticalClass: `${pfx}-vertical`,
					paginationDisabledClass: `${pfx}-disabled`
				}
			});
			swiper.pagination = {
				el: null,
				$el: null,
				bullets: []
			};
			let bulletSize;
			let dynamicBulletIndex = 0;
			function isPaginationDisabled() {
				return !swiper.params.pagination.el || !swiper.pagination.el || !swiper.pagination.$el || 0 === swiper.pagination.$el.length;
			}
			function setSideBullets($bulletEl, position) {
				const { bulletActiveClass } = swiper.params.pagination;
				$bulletEl[position]().addClass(`${bulletActiveClass}-${position}`)[position]().addClass(`${bulletActiveClass}-${position}-${position}`);
			}
			function update() {
				const rtl = swiper.rtl;
				const params = swiper.params.pagination;
				if (isPaginationDisabled()) return;
				const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
				const $el = swiper.pagination.$el;
				let current;
				const total = swiper.params.loop ? Math.ceil((slidesLength - 2 * swiper.loopedSlides) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
				if (swiper.params.loop) {
					current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
					if (current > slidesLength - 1 - 2 * swiper.loopedSlides) current -= slidesLength - 2 * swiper.loopedSlides;
					if (current > total - 1) current -= total;
					if (current < 0 && "bullets" !== swiper.params.paginationType) current = total + current;
				} else if ("undefined" !== typeof swiper.snapIndex) current = swiper.snapIndex; else current = swiper.activeIndex || 0;
				if ("bullets" === params.type && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
					const bullets = swiper.pagination.bullets;
					let firstIndex;
					let lastIndex;
					let midIndex;
					if (params.dynamicBullets) {
						bulletSize = bullets.eq(0)[swiper.isHorizontal() ? "outerWidth" : "outerHeight"](true);
						$el.css(swiper.isHorizontal() ? "width" : "height", `${bulletSize * (params.dynamicMainBullets + 4)}px`);
						if (params.dynamicMainBullets > 1 && void 0 !== swiper.previousIndex) {
							dynamicBulletIndex += current - (swiper.previousIndex - swiper.loopedSlides || 0);
							if (dynamicBulletIndex > params.dynamicMainBullets - 1) dynamicBulletIndex = params.dynamicMainBullets - 1; else if (dynamicBulletIndex < 0) dynamicBulletIndex = 0;
						}
						firstIndex = Math.max(current - dynamicBulletIndex, 0);
						lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
						midIndex = (lastIndex + firstIndex) / 2;
					}
					bullets.removeClass(["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((suffix => `${params.bulletActiveClass}${suffix}`)).join(" "));
					if ($el.length > 1) bullets.each((bullet => {
						const $bullet = dom(bullet);
						const bulletIndex = $bullet.index();
						if (bulletIndex === current) $bullet.addClass(params.bulletActiveClass);
						if (params.dynamicBullets) {
							if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) $bullet.addClass(`${params.bulletActiveClass}-main`);
							if (bulletIndex === firstIndex) setSideBullets($bullet, "prev");
							if (bulletIndex === lastIndex) setSideBullets($bullet, "next");
						}
					})); else {
						const $bullet = bullets.eq(current);
						const bulletIndex = $bullet.index();
						$bullet.addClass(params.bulletActiveClass);
						if (params.dynamicBullets) {
							const $firstDisplayedBullet = bullets.eq(firstIndex);
							const $lastDisplayedBullet = bullets.eq(lastIndex);
							for (let i = firstIndex; i <= lastIndex; i += 1) bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
							if (swiper.params.loop) if (bulletIndex >= bullets.length) {
								for (let i = params.dynamicMainBullets; i >= 0; i -= 1) bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);
								bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);
							} else {
								setSideBullets($firstDisplayedBullet, "prev");
								setSideBullets($lastDisplayedBullet, "next");
							} else {
								setSideBullets($firstDisplayedBullet, "prev");
								setSideBullets($lastDisplayedBullet, "next");
							}
						}
					}
					if (params.dynamicBullets) {
						const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
						const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
						const offsetProp = rtl ? "right" : "left";
						bullets.css(swiper.isHorizontal() ? offsetProp : "top", `${bulletsOffset}px`);
					}
				}
				if ("fraction" === params.type) {
					$el.find(classes_to_selector_classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
					$el.find(classes_to_selector_classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
				}
				if ("progressbar" === params.type) {
					let progressbarDirection;
					if (params.progressbarOpposite) progressbarDirection = swiper.isHorizontal() ? "vertical" : "horizontal"; else progressbarDirection = swiper.isHorizontal() ? "horizontal" : "vertical";
					const scale = (current + 1) / total;
					let scaleX = 1;
					let scaleY = 1;
					if ("horizontal" === progressbarDirection) scaleX = scale; else scaleY = scale;
					$el.find(classes_to_selector_classesToSelector(params.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
				}
				if ("custom" === params.type && params.renderCustom) {
					$el.html(params.renderCustom(swiper, current + 1, total));
					emit("paginationRender", $el[0]);
				} else emit("paginationUpdate", $el[0]);
				if (swiper.params.watchOverflow && swiper.enabled) $el[swiper.isLocked ? "addClass" : "removeClass"](params.lockClass);
			}
			function render() {
				const params = swiper.params.pagination;
				if (isPaginationDisabled()) return;
				const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
				const $el = swiper.pagination.$el;
				let paginationHTML = "";
				if ("bullets" === params.type) {
					let numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - 2 * swiper.loopedSlides) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
					if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.loop && numberOfBullets > slidesLength) numberOfBullets = slidesLength;
					for (let i = 0; i < numberOfBullets; i += 1) if (params.renderBullet) paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass); else paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
					$el.html(paginationHTML);
					swiper.pagination.bullets = $el.find(classes_to_selector_classesToSelector(params.bulletClass));
				}
				if ("fraction" === params.type) {
					if (params.renderFraction) paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass); else paginationHTML = `<span class="${params.currentClass}"></span>` + " / " + `<span class="${params.totalClass}"></span>`;
					$el.html(paginationHTML);
				}
				if ("progressbar" === params.type) {
					if (params.renderProgressbar) paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass); else paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
					$el.html(paginationHTML);
				}
				if ("custom" !== params.type) emit("paginationRender", swiper.pagination.$el[0]);
			}
			function init() {
				swiper.params.pagination = create_element_if_not_defined_createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
					el: "swiper-pagination"
				});
				const params = swiper.params.pagination;
				if (!params.el) return;
				let $el = dom(params.el);
				if (0 === $el.length) return;
				if (swiper.params.uniqueNavElements && "string" === typeof params.el && $el.length > 1) {
					$el = swiper.$el.find(params.el);
					if ($el.length > 1) $el = $el.filter((el => {
						if (dom(el).parents(".swiper")[0] !== swiper.el) return false;
						return true;
					}));
				}
				if ("bullets" === params.type && params.clickable) $el.addClass(params.clickableClass);
				$el.addClass(params.modifierClass + params.type);
				$el.addClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
				if ("bullets" === params.type && params.dynamicBullets) {
					$el.addClass(`${params.modifierClass}${params.type}-dynamic`);
					dynamicBulletIndex = 0;
					if (params.dynamicMainBullets < 1) params.dynamicMainBullets = 1;
				}
				if ("progressbar" === params.type && params.progressbarOpposite) $el.addClass(params.progressbarOppositeClass);
				if (params.clickable) $el.on("click", classes_to_selector_classesToSelector(params.bulletClass), (function onClick(e) {
					e.preventDefault();
					let index = dom(this).index() * swiper.params.slidesPerGroup;
					if (swiper.params.loop) index += swiper.loopedSlides;
					swiper.slideTo(index);
				}));
				Object.assign(swiper.pagination, {
					$el,
					el: $el[0]
				});
				if (!swiper.enabled) $el.addClass(params.lockClass);
			}
			function destroy() {
				const params = swiper.params.pagination;
				if (isPaginationDisabled()) return;
				const $el = swiper.pagination.$el;
				$el.removeClass(params.hiddenClass);
				$el.removeClass(params.modifierClass + params.type);
				$el.removeClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
				if (swiper.pagination.bullets && swiper.pagination.bullets.removeClass) swiper.pagination.bullets.removeClass(params.bulletActiveClass);
				if (params.clickable) $el.off("click", classes_to_selector_classesToSelector(params.bulletClass));
			}
			on("init", (() => {
				if (false === swiper.params.pagination.enabled) disable(); else {
					init();
					render();
					update();
				}
			}));
			on("activeIndexChange", (() => {
				if (swiper.params.loop) update(); else if ("undefined" === typeof swiper.snapIndex) update();
			}));
			on("snapIndexChange", (() => {
				if (!swiper.params.loop) update();
			}));
			on("slidesLengthChange", (() => {
				if (swiper.params.loop) {
					render();
					update();
				}
			}));
			on("snapGridLengthChange", (() => {
				if (!swiper.params.loop) {
					render();
					update();
				}
			}));
			on("destroy", (() => {
				destroy();
			}));
			on("enable disable", (() => {
				const { $el } = swiper.pagination;
				if ($el) $el[swiper.enabled ? "removeClass" : "addClass"](swiper.params.pagination.lockClass);
			}));
			on("lock unlock", (() => {
				update();
			}));
			on("click", ((_s, e) => {
				const targetEl = e.target;
				const { $el } = swiper.pagination;
				if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && $el && $el.length > 0 && !dom(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
					if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
					const isHidden = $el.hasClass(swiper.params.pagination.hiddenClass);
					if (true === isHidden) emit("paginationShow"); else emit("paginationHide");
					$el.toggleClass(swiper.params.pagination.hiddenClass);
				}
			}));
			const enable = () => {
				swiper.$el.removeClass(swiper.params.pagination.paginationDisabledClass);
				if (swiper.pagination.$el) swiper.pagination.$el.removeClass(swiper.params.pagination.paginationDisabledClass);
				init();
				render();
				update();
			};
			const disable = () => {
				swiper.$el.addClass(swiper.params.pagination.paginationDisabledClass);
				if (swiper.pagination.$el) swiper.pagination.$el.addClass(swiper.params.pagination.paginationDisabledClass);
				destroy();
			};
			Object.assign(swiper.pagination, {
				enable,
				disable,
				render,
				update,
				init,
				destroy
			});
		}
		function Autoplay(_ref) {
			let { swiper, extendParams, on, emit } = _ref;
			let timeout;
			swiper.autoplay = {
				running: false,
				paused: false
			};
			extendParams({
				autoplay: {
					enabled: false,
					delay: 3e3,
					waitForTransition: true,
					disableOnInteraction: true,
					stopOnLastSlide: false,
					reverseDirection: false,
					pauseOnMouseEnter: false
				}
			});
			function run() {
				if (!swiper.size) {
					swiper.autoplay.running = false;
					swiper.autoplay.paused = false;
					return;
				}
				const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
				let delay = swiper.params.autoplay.delay;
				if ($activeSlideEl.attr("data-swiper-autoplay")) delay = $activeSlideEl.attr("data-swiper-autoplay") || swiper.params.autoplay.delay;
				clearTimeout(timeout);
				timeout = utils_nextTick((() => {
					let autoplayResult;
					if (swiper.params.autoplay.reverseDirection) if (swiper.params.loop) {
						swiper.loopFix();
						autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
						emit("autoplay");
					} else if (!swiper.isBeginning) {
						autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
						emit("autoplay");
					} else if (!swiper.params.autoplay.stopOnLastSlide) {
						autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
						emit("autoplay");
					} else stop(); else if (swiper.params.loop) {
						swiper.loopFix();
						autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
						emit("autoplay");
					} else if (!swiper.isEnd) {
						autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
						emit("autoplay");
					} else if (!swiper.params.autoplay.stopOnLastSlide) {
						autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);
						emit("autoplay");
					} else stop();
					if (swiper.params.cssMode && swiper.autoplay.running) run(); else if (false === autoplayResult) run();
				}), delay);
			}
			function start() {
				if ("undefined" !== typeof timeout) return false;
				if (swiper.autoplay.running) return false;
				swiper.autoplay.running = true;
				emit("autoplayStart");
				run();
				return true;
			}
			function stop() {
				if (!swiper.autoplay.running) return false;
				if ("undefined" === typeof timeout) return false;
				if (timeout) {
					clearTimeout(timeout);
					timeout = void 0;
				}
				swiper.autoplay.running = false;
				emit("autoplayStop");
				return true;
			}
			function pause(speed) {
				if (!swiper.autoplay.running) return;
				if (swiper.autoplay.paused) return;
				if (timeout) clearTimeout(timeout);
				swiper.autoplay.paused = true;
				if (0 === speed || !swiper.params.autoplay.waitForTransition) {
					swiper.autoplay.paused = false;
					run();
				} else["transitionend", "webkitTransitionEnd"].forEach((event => {
					swiper.$wrapperEl[0].addEventListener(event, onTransitionEnd);
				}));
			}
			function onVisibilityChange() {
				const document = ssr_window_esm_getDocument();
				if ("hidden" === document.visibilityState && swiper.autoplay.running) pause();
				if ("visible" === document.visibilityState && swiper.autoplay.paused) {
					run();
					swiper.autoplay.paused = false;
				}
			}
			function onTransitionEnd(e) {
				if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
				if (e.target !== swiper.$wrapperEl[0]) return;
				["transitionend", "webkitTransitionEnd"].forEach((event => {
					swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
				}));
				swiper.autoplay.paused = false;
				if (!swiper.autoplay.running) stop(); else run();
			}
			function onMouseEnter() {
				if (swiper.params.autoplay.disableOnInteraction) stop(); else {
					emit("autoplayPause");
					pause();
				}
				["transitionend", "webkitTransitionEnd"].forEach((event => {
					swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
				}));
			}
			function onMouseLeave() {
				if (swiper.params.autoplay.disableOnInteraction) return;
				swiper.autoplay.paused = false;
				emit("autoplayResume");
				run();
			}
			function attachMouseEvents() {
				if (swiper.params.autoplay.pauseOnMouseEnter) {
					swiper.$el.on("mouseenter", onMouseEnter);
					swiper.$el.on("mouseleave", onMouseLeave);
				}
			}
			function detachMouseEvents() {
				swiper.$el.off("mouseenter", onMouseEnter);
				swiper.$el.off("mouseleave", onMouseLeave);
			}
			on("init", (() => {
				if (swiper.params.autoplay.enabled) {
					start();
					const document = ssr_window_esm_getDocument();
					document.addEventListener("visibilitychange", onVisibilityChange);
					attachMouseEvents();
				}
			}));
			on("beforeTransitionStart", ((_s, speed, internal) => {
				if (swiper.autoplay.running) if (internal || !swiper.params.autoplay.disableOnInteraction) swiper.autoplay.pause(speed); else stop();
			}));
			on("sliderFirstMove", (() => {
				if (swiper.autoplay.running) if (swiper.params.autoplay.disableOnInteraction) stop(); else pause();
			}));
			on("touchEnd", (() => {
				if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) run();
			}));
			on("destroy", (() => {
				detachMouseEvents();
				if (swiper.autoplay.running) stop();
				const document = ssr_window_esm_getDocument();
				document.removeEventListener("visibilitychange", onVisibilityChange);
			}));
			Object.assign(swiper.autoplay, {
				pause,
				run,
				start,
				stop
			});
		}
		function effect_init_effectInit(params) {
			const { effect, swiper, on, setTranslate, setTransition, overwriteParams, perspective, recreateShadows, getEffectParams } = params;
			on("beforeInit", (() => {
				if (swiper.params.effect !== effect) return;
				swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);
				if (perspective && perspective()) swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
				const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
				Object.assign(swiper.params, overwriteParamsResult);
				Object.assign(swiper.originalParams, overwriteParamsResult);
			}));
			on("setTranslate", (() => {
				if (swiper.params.effect !== effect) return;
				setTranslate();
			}));
			on("setTransition", ((_s, duration) => {
				if (swiper.params.effect !== effect) return;
				setTransition(duration);
			}));
			on("transitionEnd", (() => {
				if (swiper.params.effect !== effect) return;
				if (recreateShadows) {
					if (!getEffectParams || !getEffectParams().slideShadows) return;
					swiper.slides.each((slideEl => {
						const $slideEl = swiper.$(slideEl);
						$slideEl.find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").remove();
					}));
					recreateShadows();
				}
			}));
			let requireUpdateOnVirtual;
			on("virtualUpdate", (() => {
				if (swiper.params.effect !== effect) return;
				if (!swiper.slides.length) requireUpdateOnVirtual = true;
				requestAnimationFrame((() => {
					if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {
						setTranslate();
						requireUpdateOnVirtual = false;
					}
				}));
			}));
		}
		function effect_target_effectTarget(effectParams, $slideEl) {
			if (effectParams.transformEl) return $slideEl.find(effectParams.transformEl).css({
				"backface-visibility": "hidden",
				"-webkit-backface-visibility": "hidden"
			});
			return $slideEl;
		}
		function effect_virtual_transition_end_effectVirtualTransitionEnd(_ref) {
			let { swiper, duration, transformEl, allSlides } = _ref;
			const { slides, activeIndex, $wrapperEl } = swiper;
			if (swiper.params.virtualTranslate && 0 !== duration) {
				let eventTriggered = false;
				let $transitionEndTarget;
				if (allSlides) $transitionEndTarget = transformEl ? slides.find(transformEl) : slides; else $transitionEndTarget = transformEl ? slides.eq(activeIndex).find(transformEl) : slides.eq(activeIndex);
				$transitionEndTarget.transitionEnd((() => {
					if (eventTriggered) return;
					if (!swiper || swiper.destroyed) return;
					eventTriggered = true;
					swiper.animating = false;
					const triggerEvents = ["webkitTransitionEnd", "transitionend"];
					for (let i = 0; i < triggerEvents.length; i += 1) $wrapperEl.trigger(triggerEvents[i]);
				}));
			}
		}
		function EffectFade(_ref) {
			let { swiper, extendParams, on } = _ref;
			extendParams({
				fadeEffect: {
					crossFade: false,
					transformEl: null
				}
			});
			const setTranslate = () => {
				const { slides } = swiper;
				const params = swiper.params.fadeEffect;
				for (let i = 0; i < slides.length; i += 1) {
					const $slideEl = swiper.slides.eq(i);
					const offset = $slideEl[0].swiperSlideOffset;
					let tx = -offset;
					if (!swiper.params.virtualTranslate) tx -= swiper.translate;
					let ty = 0;
					if (!swiper.isHorizontal()) {
						ty = tx;
						tx = 0;
					}
					const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
					const $targetEl = effect_target_effectTarget(params, $slideEl);
					$targetEl.css({
						opacity: slideOpacity
					}).transform(`translate3d(${tx}px, ${ty}px, 0px)`);
				}
			};
			const setTransition = duration => {
				const { transformEl } = swiper.params.fadeEffect;
				const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
				$transitionElements.transition(duration);
				effect_virtual_transition_end_effectVirtualTransitionEnd({
					swiper,
					duration,
					transformEl,
					allSlides: true
				});
			};
			effect_init_effectInit({
				effect: "fade",
				swiper,
				on,
				setTranslate,
				setTransition,
				overwriteParams: () => ({
					slidesPerView: 1,
					slidesPerGroup: 1,
					watchSlidesProgress: true,
					spaceBetween: 0,
					virtualTranslate: !swiper.params.cssMode
				})
			});
		}
		//Слайды
		if (document.querySelector(".produce__slider")) {
			var produceSlider = null;
			var mediaQuerySize = 767.98;
			function produceSliderInit() {
				if (!produceSlider) {
					produceSlider = new core(".produce__slider", {
						modules: [Pagination, Navigation],
						observer: true,
						observeParents: true,
						speed: 800,
						spaceBetween: 16,
						autoHeight: true,
						pagination: {
							el: ".produce__pagination-bullets",
							type: "custom",
							renderCustom: function (swiper, current, total) {
								document.querySelector(".swiper-pagination-current").textContent = current;
								document.querySelector(".swiper-pagination-total").textContent = total;
								let bullets = "";
								const maxVisible = 6;
								let start = 1;
								let end = Math.min(total, maxVisible);
								if (total > maxVisible) {
									start = Math.max(1, current - Math.floor(maxVisible / 2));
									start = Math.min(start, total - maxVisible + 1);
									end = start + maxVisible - 1;
								}
								for (let i = start; i <= end; i++) bullets += `<span class="swiper-pagination-bullet ${current === i ? "swiper-pagination-bullet-active" : ""}" data-index="${i}"></span>`;
								return bullets;
							}
						},
						navigation: {
							prevEl: ".produce__arrow-prev",
							nextEl: ".produce__arrow-next"
						},
						breakpoints: {
							0: {
								slidesPerView: 1.1
							},
							480: {
								slidesPerView: 1.5
							}
						}
					});
					document.querySelector(".produce__pagination-bullets").addEventListener("click", (function (e) {
						if (e.target.classList.contains("swiper-pagination-bullet")) {
							const index = parseInt(e.target.getAttribute("data-index"));
							produceSlider.slideTo(index - 1);
						}
					}));
				}
			}
			function produceSliderDestroy() {
				if (produceSlider) {
					produceSlider.destroy();
					produceSlider = null;
				}
			}
			window.addEventListener("resize", (function (e) {
				var windowWidth = window.innerWidth;
				if (windowWidth <= mediaQuerySize) produceSliderInit(); else produceSliderDestroy();
			}));
			window.addEventListener("load", (function (e) {
				var windowWidth = window.innerWidth;
				if (windowWidth <= mediaQuerySize) produceSliderInit(); else produceSliderDestroy();
			}));
		}
		if (document.querySelector(".reviews__slider")) {
			const reviewsSlider = new core(".reviews__slider", {
				modules: [Pagination, Navigation],
				observer: true,
				observeParents: true,
				speed: 800,
				slidesPerView: 3,
				spaceBetween: 16,
				autoHeight: false,
				loop: false,
				watchSlidesProgress: true,
				watchSlidesVisibility: true,
				resistance: true,
				resistanceRatio: .85,
				preventInteractionOnTransition: true,
				pagination: {
					el: ".reviews__pagination-bullets",
					type: "custom",
					renderCustom: function (swiper, current, total) {
						const fractionElement = document.querySelector(".reviews__pagination-fraction");
						if (fractionElement) {
							fractionElement.querySelector(".swiper-pagination-current").textContent = current;
							fractionElement.querySelector(".swiper-pagination-total").textContent = total;
						}
						let bullets = "";
						const maxVisible = 6;
						let start = 1;
						let end = Math.min(total, maxVisible);
						if (total > maxVisible) {
							start = Math.max(1, current - Math.floor(maxVisible / 2));
							start = Math.min(start, total - maxVisible + 1);
							end = start + maxVisible - 1;
						}
						for (let i = start; i <= end; i++) bullets += `<span class="swiper-pagination-bullet ${current === i ? "swiper-pagination-bullet-active" : ""}" data-index="${i}"></span>`;
						return bullets;
					}
				},
				navigation: {
					prevEl: ".reviews__arrow-prev",
					nextEl: ".reviews__arrow-next"
				},
				breakpoints: {
					0: {
						slidesPerView: 1.15
					},
					479.98: {
						slidesPerView: 1.5
					},
					767.98: {
						slidesPerView: 2.5
					},
					1200: {
						slidesPerView: 3
					}
				}
			});
			document.querySelector(".reviews__pagination-bullets")?.addEventListener("click", (function (e) {
				if (e.target.classList.contains("swiper-pagination-bullet")) {
					const index = parseInt(e.target.getAttribute("data-index"));
					reviewsSlider.slideTo(index - 1);
				}
			}));
		}
		//Динамический адаптив
		function DynamicAdapt(type) {
			this.type = type;
		}
		DynamicAdapt.prototype.init = function () {
			const _this = this;
			this.оbjects = [];
			this.daClassname = "_dynamic_adapt_";
			this.nodes = document.querySelectorAll("[data-da]");
			for (let i = 0; i < this.nodes.length; i++) {
				const node = this.nodes[i];
				const data = node.dataset.da.trim();
				const dataArray = data.split(",");
				const оbject = {};
				оbject.element = node;
				оbject.parent = node.parentNode;
				оbject.destination = document.querySelector(dataArray[0].trim());
				оbject.breakpoint = dataArray[1] ? dataArray[1].trim() : "767";
				оbject.place = dataArray[2] ? dataArray[2].trim() : "last";
				оbject.index = this.indexInParent(оbject.parent, оbject.element);
				this.оbjects.push(оbject);
			}
			this.arraySort(this.оbjects);
			this.mediaQueries = Array.prototype.map.call(this.оbjects, (function (item) {
				return "(" + this.type + "-width: " + item.breakpoint + "px)," + item.breakpoint;
			}), this);
			this.mediaQueries = Array.prototype.filter.call(this.mediaQueries, (function (item, index, self) {
				return Array.prototype.indexOf.call(self, item) === index;
			}));
			for (let i = 0; i < this.mediaQueries.length; i++) {
				const media = this.mediaQueries[i];
				const mediaSplit = String.prototype.split.call(media, ",");
				const matchMedia = window.matchMedia(mediaSplit[0]);
				const mediaBreakpoint = mediaSplit[1];
				const оbjectsFilter = Array.prototype.filter.call(this.оbjects, (function (item) {
					return item.breakpoint === mediaBreakpoint;
				}));
				matchMedia.addListener((function () {
					_this.mediaHandler(matchMedia, оbjectsFilter);
				}));
				this.mediaHandler(matchMedia, оbjectsFilter);
			}
		};
		DynamicAdapt.prototype.mediaHandler = function (matchMedia, оbjects) {
			if (matchMedia.matches) for (let i = 0; i < оbjects.length; i++) {
				const оbject = оbjects[i];
				оbject.index = this.indexInParent(оbject.parent, оbject.element);
				this.moveTo(оbject.place, оbject.element, оbject.destination);
			} else for (let i = оbjects.length - 1; i >= 0; i--) {
				const оbject = оbjects[i];
				if (оbject.element.classList.contains(this.daClassname)) this.moveBack(оbject.parent, оbject.element, оbject.index);
			}
		};
		DynamicAdapt.prototype.moveTo = function (place, element, destination) {
			element.classList.add(this.daClassname);
			if ("last" === place || place >= destination.children.length) {
				destination.insertAdjacentElement("beforeend", element);
				return;
			}
			if ("first" === place) {
				destination.insertAdjacentElement("afterbegin", element);
				return;
			}
			destination.children[place].insertAdjacentElement("beforebegin", element);
		};
		DynamicAdapt.prototype.moveBack = function (parent, element, index) {
			element.classList.remove(this.daClassname);
			if (void 0 !== parent.children[index]) parent.children[index].insertAdjacentElement("beforebegin", element); else parent.insertAdjacentElement("beforeend", element);
		};
		DynamicAdapt.prototype.indexInParent = function (parent, element) {
			const array = Array.prototype.slice.call(parent.children);
			return Array.prototype.indexOf.call(array, element);
		};
		DynamicAdapt.prototype.arraySort = function (arr) {
			if ("min" === this.type) Array.prototype.sort.call(arr, (function (a, b) {
				if (a.breakpoint === b.breakpoint) {
					if (a.place === b.place) return 0;
					if ("first" === a.place || "last" === b.place) return -1;
					if ("last" === a.place || "first" === b.place) return 1;
					return a.place - b.place;
				}
				return a.breakpoint - b.breakpoint;
			})); else {
				Array.prototype.sort.call(arr, (function (a, b) {
					if (a.breakpoint === b.breakpoint) {
						if (a.place === b.place) return 0;
						if ("first" === a.place || "last" === b.place) return 1;
						if ("last" === a.place || "first" === b.place) return -1;
						return b.place - a.place;
					}
					return b.breakpoint - a.breakpoint;
				}));
				return;
			}
		};
		const da = new DynamicAdapt("max");
		da.init();
		//Функции
		function indents() {
			const header = document.querySelector(".header");
			const page = document.querySelector(".page");
			let hHeader = window.getComputedStyle(header, false).height;
			hHeader = Number(hHeader.slice(0, hHeader.length - 2));
			if (page) page.style.paddingTop = hHeader + "px";
		}
		window.addEventListener("scroll", (() => {
			indents();
		}));
		window.addEventListener("resize", (() => {
			indents();
		}));
		indents();
		const videoObserver = new IntersectionObserver((entries => {
			entries.forEach((entry => {
				if (entry.isIntersecting) {
					const video = entry.target;
					const sources = video.querySelectorAll("source");
					sources.forEach((source => {
						if (source.dataset.src) source.src = source.dataset.src;
					}));
					video.load();
					videoObserver.unobserve(video);
				}
			}));
		}), {
			threshold: .1
		});
		document.querySelectorAll(".popup__item-video").forEach((video => {
			videoObserver.observe(video);
		}));
		class VideoPopup {
			constructor(container) {
				this.popups = document.querySelectorAll(container);
				this.init();
			}
			init() {
				this.popups.forEach((popup => {
					const video = popup.querySelector("video");
					popup.querySelector("[data-close]");
					popup.addEventListener("click", (e => {
						if (e.target.closest("[data-close]") || e.target === popup) video.pause(); else if (!video.src && video.dataset.src) {
							video.querySelector("source").src = video.dataset.src;
							video.load();
						}
					}));
				}));
			}
		}
		new VideoPopup(".popup.video");
		//Скролл

		let addWindowScrollEvent = false;
		setTimeout((() => {
			if (addWindowScrollEvent) {
				let windowScroll = new Event("windowScroll");
				window.addEventListener("scroll", (function (e) {
					document.dispatchEvent(windowScroll);
				}));
			}
		}), 0);
		//Ленивая загрузка
		const lazyMedia = new lazyLoad({
			elements_selector: '[data-src],[data-srcset]',
			class_loaded: '_lazy-loaded',
			use_native: true
		});
	</script>
	<div id="video1" aria-hidden="true" class="popup video">
		<div class="popup__wrapper">
			<div class="popup__content">
				<div data-close class="popup__close">
					<svg width="23" height="23" viewBox="0 0 23 23" fill="none" xmlns="http://www.w3.org/2000/svg">
						<path opacity="0.850056" d="M1.73333 1.48883L21.5469 21.0288" stroke="#fff" stroke-width="2"
							stroke-linecap="square" />
						<path opacity="0.850056" d="M21.2667 1.48877L1.45312 21.0287" stroke="white" stroke-width="2"
							stroke-linecap="square" />
					</svg>
				</div>
				<div class="popup__video">
					<video playsinline controls muted preload="none" poster="img/produce/image1.png"
						class="popup__item-video" data-src="./files/videos/video.mp4">
						<source src="./files/videos/video.mp4" type="video/mp4">
					</video>
				</div>
			</div>
		</div>
	</div>
	<div id="video2" aria-hidden="true" class="popup video">
		<div class="popup__wrapper">
			<div class="popup__content">
				<div data-close class="popup__close">
					<svg width="23" height="23" viewBox="0 0 23 23" fill="none" xmlns="http://www.w3.org/2000/svg">
						<path opacity="0.850056" d="M1.73333 1.48883L21.5469 21.0288" stroke="#fff" stroke-width="2"
							stroke-linecap="square" />
						<path opacity="0.850056" d="M21.2667 1.48877L1.45312 21.0287" stroke="white" stroke-width="2"
							stroke-linecap="square" />
					</svg>
				</div>
				<div class="popup__video">
					<video playsinline controls muted preload="none" poster="img/produce/image1.png"
						class="popup__item-video" data-src="./files/videos/video.mp4">
						<source src="./files/videos/video.mp4" type="video/mp4">
					</video>
				</div>
			</div>
		</div>
	</div>
	<div id="video3" aria-hidden="true" class="popup video">
		<div class="popup__wrapper">
			<div class="popup__content">
				<div data-close class="popup__close">
					<svg width="23" height="23" viewBox="0 0 23 23" fill="none" xmlns="http://www.w3.org/2000/svg">
						<path opacity="0.850056" d="M1.73333 1.48883L21.5469 21.0288" stroke="#fff" stroke-width="2"
							stroke-linecap="square" />
						<path opacity="0.850056" d="M21.2667 1.48877L1.45312 21.0287" stroke="white" stroke-width="2"
							stroke-linecap="square" />
					</svg>
				</div>
				<div class="popup__video">
					<video playsinline controls muted preload="none" poster="img/produce/image1.png"
						class="popup__item-video" data-src="./files/videos/video.mp4">
						<source src="./files/videos/video.mp4" type="video/mp4">
					</video>
				</div>
			</div>
		</div>
	</div>
	<div id="video4" aria-hidden="true" class="popup video">
		<div class="popup__wrapper">
			<div class="popup__content">
				<div data-close class="popup__close">
					<svg width="23" height="23" viewBox="0 0 23 23" fill="none" xmlns="http://www.w3.org/2000/svg">
						<path opacity="0.850056" d="M1.73333 1.48883L21.5469 21.0288" stroke="#fff" stroke-width="2"
							stroke-linecap="square" />
						<path opacity="0.850056" d="M21.2667 1.48877L1.45312 21.0287" stroke="white" stroke-width="2"
							stroke-linecap="square" />
					</svg>
				</div>
				<div class="popup__video">
					<video playsinline controls muted preload="none" poster="img/produce/image1.png"
						class="popup__item-video" data-src="./files/videos/video.mp4">
						<source src="./files/videos/video.mp4" type="video/mp4">
					</video>
				</div>
			</div>
		</div>
	</div>
	<div id="video5" aria-hidden="true" class="popup video">
		<div class="popup__wrapper">
			<div class="popup__content">
				<div data-close class="popup__close">
					<svg width="23" height="23" viewBox="0 0 23 23" fill="none" xmlns="http://www.w3.org/2000/svg">
						<path opacity="0.850056" d="M1.73333 1.48883L21.5469 21.0288" stroke="#fff" stroke-width="2"
							stroke-linecap="square" />
						<path opacity="0.850056" d="M21.2667 1.48877L1.45312 21.0287" stroke="white" stroke-width="2"
							stroke-linecap="square" />
					</svg>
				</div>
				<div class="popup__video">
					<video playsinline controls muted preload="none" poster="img/produce/image1.png"
						class="popup__item-video" data-src="./files/videos/video.mp4">
						<source src="./files/videos/video.mp4" type="video/mp4">
					</video>
				</div>
			</div>
		</div>
	</div>
	<div id="video6" aria-hidden="true" class="popup video">
		<div class="popup__wrapper">
			<div class="popup__content">
				<div data-close class="popup__close">
					<svg width="23" height="23" viewBox="0 0 23 23" fill="none" xmlns="http://www.w3.org/2000/svg">
						<path opacity="0.850056" d="M1.73333 1.48883L21.5469 21.0288" stroke="#fff" stroke-width="2"
							stroke-linecap="square" />
						<path opacity="0.850056" d="M21.2667 1.48877L1.45312 21.0287" stroke="white" stroke-width="2"
							stroke-linecap="square" />
					</svg>
				</div>
				<div class="popup__video">
					<video playsinline controls muted preload="none" poster="img/produce/image1.png"
						class="popup__item-video" data-src="./files/videos/video.mp4">
						<source src="./files/videos/video.mp4" type="video/mp4">
					</video>
				</div>
			</div>
		</div>
	</div>
	<div id="video7" aria-hidden="true" class="popup video">
		<div class="popup__wrapper">
			<div class="popup__content">
				<div data-close class="popup__close">
					<svg width="23" height="23" viewBox="0 0 23 23" fill="none" xmlns="http://www.w3.org/2000/svg">
						<path opacity="0.850056" d="M1.73333 1.48883L21.5469 21.0288" stroke="#fff" stroke-width="2"
							stroke-linecap="square" />
						<path opacity="0.850056" d="M21.2667 1.48877L1.45312 21.0287" stroke="white" stroke-width="2"
							stroke-linecap="square" />
					</svg>
				</div>
				<div class="popup__video">
					<video playsinline controls muted preload="none" poster="img/produce/image1.png"
						class="popup__item-video" data-src="./files/videos/video.mp4">
						<source src="./files/videos/video.mp4" type="video/mp4">
					</video>
				</div>
			</div>
		</div>
	</div>
	<div id="video8" aria-hidden="true" class="popup video">
		<div class="popup__wrapper">
			<div class="popup__content">
				<div data-close class="popup__close">
					<svg width="23" height="23" viewBox="0 0 23 23" fill="none" xmlns="http://www.w3.org/2000/svg">
						<path opacity="0.850056" d="M1.73333 1.48883L21.5469 21.0288" stroke="#fff" stroke-width="2"
							stroke-linecap="square" />
						<path opacity="0.850056" d="M21.2667 1.48877L1.45312 21.0287" stroke="white" stroke-width="2"
							stroke-linecap="square" />
					</svg>
				</div>
				<div class="popup__video">
					<video playsinline controls muted preload="none" poster="img/produce/image1.png"
						class="popup__item-video" data-src="./files/videos/video.mp4">
						<source src="./files/videos/video.mp4" type="video/mp4">
					</video>
				</div>
			</div>
		</div>
	</div>
	<div id="video9" aria-hidden="true" class="popup video">
		<div class="popup__wrapper">
			<div class="popup__content">
				<div data-close class="popup__close">
					<svg width="23" height="23" viewBox="0 0 23 23" fill="none" xmlns="http://www.w3.org/2000/svg">
						<path opacity="0.850056" d="M1.73333 1.48883L21.5469 21.0288" stroke="#fff" stroke-width="2"
							stroke-linecap="square" />
						<path opacity="0.850056" d="M21.2667 1.48877L1.45312 21.0287" stroke="white" stroke-width="2"
							stroke-linecap="square" />
					</svg>
				</div>
				<div class="popup__video">
					<video playsinline controls muted preload="none" poster="img/produce/image1.png"
						class="popup__item-video" data-src="./files/videos/video.mp4">
						<source src="./files/videos/video.mp4" type="video/mp4">
					</video>
				</div>
			</div>
		</div>
	</div>
	<div id="video10" aria-hidden="true" class="popup video">
		<div class="popup__wrapper">
			<div class="popup__content">
				<div data-close class="popup__close">
					<svg width="23" height="23" viewBox="0 0 23 23" fill="none" xmlns="http://www.w3.org/2000/svg">
						<path opacity="0.850056" d="M1.73333 1.48883L21.5469 21.0288" stroke="#fff" stroke-width="2"
							stroke-linecap="square" />
						<path opacity="0.850056" d="M21.2667 1.48877L1.45312 21.0287" stroke="white" stroke-width="2"
							stroke-linecap="square" />
					</svg>
				</div>
				<div class="popup__video">
					<video playsinline controls muted preload="none" poster="img/produce/image1.png"
						class="popup__item-video" data-src="./files/videos/video.mp4">
						<source src="./files/videos/video.mp4" type="video/mp4">
					</video>
				</div>
			</div>
		</div>
	</div>
	<div id="video11" aria-hidden="true" class="popup video">
		<div class="popup__wrapper">
			<div class="popup__content">
				<div data-close class="popup__close">
					<svg width="23" height="23" viewBox="0 0 23 23" fill="none" xmlns="http://www.w3.org/2000/svg">
						<path opacity="0.850056" d="M1.73333 1.48883L21.5469 21.0288" stroke="#fff" stroke-width="2"
							stroke-linecap="square" />
						<path opacity="0.850056" d="M21.2667 1.48877L1.45312 21.0287" stroke="white" stroke-width="2"
							stroke-linecap="square" />
					</svg>
				</div>
				<div class="popup__video">
					<video playsinline controls muted preload="none" poster="img/produce/image1.png"
						class="popup__item-video" data-src="./files/videos/video.mp4">
						<source src="./files/videos/video.mp4" type="video/mp4">
					</video>
				</div>
			</div>
		</div>
	</div>
	<div id="video12" aria-hidden="true" class="popup video">
		<div class="popup__wrapper">
			<div class="popup__content">
				<div data-close class="popup__close">
					<svg width="23" height="23" viewBox="0 0 23 23" fill="none" xmlns="http://www.w3.org/2000/svg">
						<path opacity="0.850056" d="M1.73333 1.48883L21.5469 21.0288" stroke="#fff" stroke-width="2"
							stroke-linecap="square" />
						<path opacity="0.850056" d="M21.2667 1.48877L1.45312 21.0287" stroke="white" stroke-width="2"
							stroke-linecap="square" />
					</svg>
				</div>
				<div class="popup__video">
					<video playsinline controls muted preload="none" poster="img/produce/image1.png"
						class="popup__item-video" data-src="./files/videos/video.mp4">
						<source src="./files/videos/video.mp4" type="video/mp4">
					</video>
				</div>
			</div>
		</div>
	</div>
	<div id="video13" aria-hidden="true" class="popup video">
		<div class="popup__wrapper">
			<div class="popup__content">
				<div data-close class="popup__close">
					<svg width="23" height="23" viewBox="0 0 23 23" fill="none" xmlns="http://www.w3.org/2000/svg">
						<path opacity="0.850056" d="M1.73333 1.48883L21.5469 21.0288" stroke="#fff" stroke-width="2"
							stroke-linecap="square" />
						<path opacity="0.850056" d="M21.2667 1.48877L1.45312 21.0287" stroke="white" stroke-width="2"
							stroke-linecap="square" />
					</svg>
				</div>
				<div class="popup__video">
					<video playsinline controls muted preload="none" poster="img/produce/image1.png"
						class="popup__item-video" data-src="./files/videos/video.mp4">
						<source src="./files/videos/video.mp4" type="video/mp4">
					</video>
				</div>
			</div>
		</div>
	</div>
	<div id="video14" aria-hidden="true" class="popup video">
		<div class="popup__wrapper">
			<div class="popup__content">
				<div data-close class="popup__close">
					<svg width="23" height="23" viewBox="0 0 23 23" fill="none" xmlns="http://www.w3.org/2000/svg">
						<path opacity="0.850056" d="M1.73333 1.48883L21.5469 21.0288" stroke="#fff" stroke-width="2"
							stroke-linecap="square" />
						<path opacity="0.850056" d="M21.2667 1.48877L1.45312 21.0287" stroke="white" stroke-width="2"
							stroke-linecap="square" />
					</svg>
				</div>
				<div class="popup__video">
					<video playsinline controls muted preload="none" poster="img/produce/image1.png"
						class="popup__item-video" data-src="./files/videos/video.mp4">
						<source src="./files/videos/video.mp4" type="video/mp4">
					</video>
				</div>
			</div>
		</div>
	</div>
	<div id="video15" aria-hidden="true" class="popup video">
		<div class="popup__wrapper">
			<div class="popup__content">
				<div data-close class="popup__close">
					<svg width="23" height="23" viewBox="0 0 23 23" fill="none" xmlns="http://www.w3.org/2000/svg">
						<path opacity="0.850056" d="M1.73333 1.48883L21.5469 21.0288" stroke="#fff" stroke-width="2"
							stroke-linecap="square" />
						<path opacity="0.850056" d="M21.2667 1.48877L1.45312 21.0287" stroke="white" stroke-width="2"
							stroke-linecap="square" />
					</svg>
				</div>
				<div class="popup__video">
					<video playsinline controls muted preload="none" poster="img/produce/image1.png"
						class="popup__item-video" data-src="./files/videos/video.mp4">
						<source src="./files/videos/video.mp4" type="video/mp4">
					</video>
				</div>
			</div>
		</div>
	</div>
</body>

</html>